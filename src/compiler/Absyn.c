/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/* C Abstract Syntax Implementation. */

#include "Absyn.h"
#include <stdio.h>
#include <stdlib.h>

/********************   ProgramRoot    ********************/

Program make_ProgramRoot( LeadingEols p1, TopDecls p2, Defs p3 )
{
   Program tmp = ( Program ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ProgramRoot!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_ProgramRoot;
   tmp->u.programRoot_.leadingeols_ = p1;
   tmp->u.programRoot_.topdecls_    = p2;
   tmp->u.programRoot_.defs_        = p3;
   return tmp;
}

/********************   LeadingEolsEmpty    ********************/

LeadingEols make_LeadingEolsEmpty()
{
   LeadingEols tmp = ( LeadingEols ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LeadingEolsEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_LeadingEolsEmpty;
   return tmp;
}

/********************   ListTopDeclEmpty    ********************/

TopDecls make_ListTopDeclEmpty()
{
   TopDecls tmp = ( TopDecls ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListTopDeclEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListTopDeclEmpty;
   return tmp;
}

/********************   ListTopDeclCons    ********************/

TopDecls make_ListTopDeclCons( TopDecl p1, TopDecls p2 )
{
   TopDecls tmp = ( TopDecls ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListTopDeclCons!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_ListTopDeclCons;
   tmp->u.listTopDeclCons_.topdecl_  = p1;
   tmp->u.listTopDeclCons_.topdecls_ = p2;
   return tmp;
}

/********************   ListTopDeclLine    ********************/

TopDecls make_ListTopDeclLine( LineEol p1, TopDecls p2 )
{
   TopDecls tmp = ( TopDecls ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListTopDeclLine!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_ListTopDeclLine;
   tmp->u.listTopDeclLine_.lineeol_  = p1;
   tmp->u.listTopDeclLine_.topdecls_ = p2;
   return tmp;
}

/********************   TopDeclEnum    ********************/

TopDecl make_TopDeclEnum( EnumDecl p1 )
{
   TopDecl tmp = ( TopDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating TopDeclEnum!\n" );
      exit( 1 );
   }
   tmp->kind                     = is_TopDeclEnum;
   tmp->u.topDeclEnum_.enumdecl_ = p1;
   return tmp;
}

/********************   TopDeclClass    ********************/

TopDecl make_TopDeclClass( ClassDecl p1 )
{
   TopDecl tmp = ( TopDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating TopDeclClass!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_TopDeclClass;
   tmp->u.topDeclClass_.classdecl_ = p1;
   return tmp;
}

/********************   TopDeclStruct    ********************/

TopDecl make_TopDeclStruct( StructDecl p1 )
{
   TopDecl tmp = ( TopDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating TopDeclStruct!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_TopDeclStruct;
   tmp->u.topDeclStruct_.structdecl_ = p1;
   return tmp;
}

/********************   TopDeclPreproc    ********************/

TopDecl make_TopDeclPreproc( PreprocDecl p1 )
{
   TopDecl tmp = ( TopDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating TopDeclPreproc!\n" );
      exit( 1 );
   }
   tmp->kind                           = is_TopDeclPreproc;
   tmp->u.topDeclPreproc_.preprocdecl_ = p1;
   return tmp;
}

/********************   TopDeclStatic    ********************/

TopDecl make_TopDeclStatic( StaticDecl p1 )
{
   TopDecl tmp = ( TopDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating TopDeclStatic!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_TopDeclStatic;
   tmp->u.topDeclStatic_.staticdecl_ = p1;
   return tmp;
}

/********************   ListDefSingle    ********************/

Defs make_ListDefSingle( Def p1 )
{
   Defs tmp = ( Defs ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListDefSingle!\n" );
      exit( 1 );
   }
   tmp->kind                  = is_ListDefSingle;
   tmp->u.listDefSingle_.def_ = p1;
   return tmp;
}

/********************   ListDefCons    ********************/

Defs make_ListDefCons( Def p1, Defs p2 )
{
   Defs tmp = ( Defs ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListDefCons!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ListDefCons;
   tmp->u.listDefCons_.def_  = p1;
   tmp->u.listDefCons_.defs_ = p2;
   return tmp;
}

/********************   PreprocDeclLine    ********************/

PreprocDecl make_PreprocDeclLine( PreprocLine p1, StmtEnd p2 )
{
   PreprocDecl tmp = ( PreprocDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating PreprocDeclLine!\n" );
      exit( 1 );
   }
   tmp->kind                            = is_PreprocDeclLine;
   tmp->u.preprocDeclLine_.preprocline_ = p1;
   tmp->u.preprocDeclLine_.stmtend_     = p2;
   return tmp;
}

/********************   OptParamListEmpty    ********************/

ParamListOpt make_OptParamListEmpty()
{
   ParamListOpt tmp = ( ParamListOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptParamListEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptParamListEmpty;
   return tmp;
}

/********************   OptParamListSome    ********************/

ParamListOpt make_OptParamListSome( Ident p1, ParamListTail p2 )
{
   ParamListOpt tmp = ( ParamListOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptParamListSome!\n" );
      exit( 1 );
   }
   tmp->kind                               = is_OptParamListSome;
   tmp->u.optParamListSome_.ident_         = p1;
   tmp->u.optParamListSome_.paramlisttail_ = p2;
   return tmp;
}

/********************   ListParamTailEmpty    ********************/

ParamListTail make_ListParamTailEmpty()
{
   ParamListTail tmp = ( ParamListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListParamTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListParamTailEmpty;
   return tmp;
}

/********************   ListParamTailCons    ********************/

ParamListTail make_ListParamTailCons( Ident p1, ParamListTail p2 )
{
   ParamListTail tmp = ( ParamListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListParamTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                                = is_ListParamTailCons;
   tmp->u.listParamTailCons_.ident_         = p1;
   tmp->u.listParamTailCons_.paramlisttail_ = p2;
   return tmp;
}

/********************   StmtAssignInl    ********************/

Stmt make_StmtAssignInl( LHS p1, Expr p2, StmtEnd p3 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtAssignInl!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_StmtAssignInl;
   tmp->u.stmtAssignInl_.lhs_     = p1;
   tmp->u.stmtAssignInl_.expr_    = p2;
   tmp->u.stmtAssignInl_.stmtend_ = p3;
   return tmp;
}

/********************   StmtAssignAdd    ********************/

Stmt make_StmtAssignAdd( LHS p1, Expr p2, StmtEnd p3 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtAssignAdd!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_StmtAssignAdd;
   tmp->u.stmtAssignAdd_.lhs_     = p1;
   tmp->u.stmtAssignAdd_.expr_    = p2;
   tmp->u.stmtAssignAdd_.stmtend_ = p3;
   return tmp;
}

/********************   StmtAssignSub    ********************/

Stmt make_StmtAssignSub( LHS p1, Expr p2, StmtEnd p3 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtAssignSub!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_StmtAssignSub;
   tmp->u.stmtAssignSub_.lhs_     = p1;
   tmp->u.stmtAssignSub_.expr_    = p2;
   tmp->u.stmtAssignSub_.stmtend_ = p3;
   return tmp;
}

/********************   StmtAssignMul    ********************/

Stmt make_StmtAssignMul( LHS p1, Expr p2, StmtEnd p3 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtAssignMul!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_StmtAssignMul;
   tmp->u.stmtAssignMul_.lhs_     = p1;
   tmp->u.stmtAssignMul_.expr_    = p2;
   tmp->u.stmtAssignMul_.stmtend_ = p3;
   return tmp;
}

/********************   StmtAssignDiv    ********************/

Stmt make_StmtAssignDiv( LHS p1, Expr p2, StmtEnd p3 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtAssignDiv!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_StmtAssignDiv;
   tmp->u.stmtAssignDiv_.lhs_     = p1;
   tmp->u.stmtAssignDiv_.expr_    = p2;
   tmp->u.stmtAssignDiv_.stmtend_ = p3;
   return tmp;
}

/********************   StmtAssignMod    ********************/

Stmt make_StmtAssignMod( LHS p1, Expr p2, StmtEnd p3 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtAssignMod!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_StmtAssignMod;
   tmp->u.stmtAssignMod_.lhs_     = p1;
   tmp->u.stmtAssignMod_.expr_    = p2;
   tmp->u.stmtAssignMod_.stmtend_ = p3;
   return tmp;
}

/********************   StmtAssignPow    ********************/

Stmt make_StmtAssignPow( LHS p1, Expr p2, StmtEnd p3 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtAssignPow!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_StmtAssignPow;
   tmp->u.stmtAssignPow_.lhs_     = p1;
   tmp->u.stmtAssignPow_.expr_    = p2;
   tmp->u.stmtAssignPow_.stmtend_ = p3;
   return tmp;
}

/********************   StmtAssignPow2    ********************/

Stmt make_StmtAssignPow2( LHS p1, Expr p2, StmtEnd p3 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtAssignPow2!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_StmtAssignPow2;
   tmp->u.stmtAssignPow2_.lhs_     = p1;
   tmp->u.stmtAssignPow2_.expr_    = p2;
   tmp->u.stmtAssignPow2_.stmtend_ = p3;
   return tmp;
}

/********************   StmtCall    ********************/

Stmt make_StmtCall( CallExpr p1, StmtEnd p2 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtCall!\n" );
      exit( 1 );
   }
   tmp->kind                  = is_StmtCall;
   tmp->u.stmtCall_.callexpr_ = p1;
   tmp->u.stmtCall_.stmtend_  = p2;
   return tmp;
}

/********************   StmtIf    ********************/

Stmt make_StmtIf( IfCond p1, LineEol p2, StmtList p3, ElseIfList p4, ElseOpt p5, EndIf p6, StmtEnd p7 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtIf!\n" );
      exit( 1 );
   }
   tmp->kind                  = is_StmtIf;
   tmp->u.stmtIf_.ifcond_     = p1;
   tmp->u.stmtIf_.lineeol_    = p2;
   tmp->u.stmtIf_.stmtlist_   = p3;
   tmp->u.stmtIf_.elseiflist_ = p4;
   tmp->u.stmtIf_.elseopt_    = p5;
   tmp->u.stmtIf_.endif_      = p6;
   tmp->u.stmtIf_.stmtend_    = p7;
   return tmp;
}

/********************   StmtDoWhile    ********************/

Stmt make_StmtDoWhile( DoOpt p1, WhileCond p2, LineEol p3, StmtList p4, EndDo p5, StmtEnd p6 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtDoWhile!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_StmtDoWhile;
   tmp->u.stmtDoWhile_.doopt_     = p1;
   tmp->u.stmtDoWhile_.whilecond_ = p2;
   tmp->u.stmtDoWhile_.lineeol_   = p3;
   tmp->u.stmtDoWhile_.stmtlist_  = p4;
   tmp->u.stmtDoWhile_.enddo_     = p5;
   tmp->u.stmtDoWhile_.stmtend_   = p6;
   return tmp;
}

/********************   StmtFor    ********************/

Stmt make_StmtFor( Ident p1, Expr p2, Expr p3, StepOpt p4, LineEol p5, StmtList p6, EndFor p7, StmtEnd p8 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtFor!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_StmtFor;
   tmp->u.stmtFor_.ident_    = p1;
   tmp->u.stmtFor_.expr_1    = p2;
   tmp->u.stmtFor_.expr_2    = p3;
   tmp->u.stmtFor_.stepopt_  = p4;
   tmp->u.stmtFor_.lineeol_  = p5;
   tmp->u.stmtFor_.stmtlist_ = p6;
   tmp->u.stmtFor_.endfor_   = p7;
   tmp->u.stmtFor_.stmtend_  = p8;
   return tmp;
}

/********************   StmtForEach    ********************/

Stmt make_StmtForEach( ForEachVars p1, ForEachExprs p2, ForEachDescOpt p3, LineEol p4, StmtList p5, EndFor p6,
                       StmtEnd p7 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtForEach!\n" );
      exit( 1 );
   }
   tmp->kind                           = is_StmtForEach;
   tmp->u.stmtForEach_.foreachvars_    = p1;
   tmp->u.stmtForEach_.foreachexprs_   = p2;
   tmp->u.stmtForEach_.foreachdescopt_ = p3;
   tmp->u.stmtForEach_.lineeol_        = p4;
   tmp->u.stmtForEach_.stmtlist_       = p5;
   tmp->u.stmtForEach_.endfor_         = p6;
   tmp->u.stmtForEach_.stmtend_        = p7;
   return tmp;
}

/********************   StmtSwitch    ********************/

Stmt make_StmtSwitch( SwitchCond p1, LineEol p2, CaseList p3, OtherwiseOpt p4, EndSwitch p5, StmtEnd p6 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtSwitch!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_StmtSwitch;
   tmp->u.stmtSwitch_.switchcond_   = p1;
   tmp->u.stmtSwitch_.lineeol_      = p2;
   tmp->u.stmtSwitch_.caselist_     = p3;
   tmp->u.stmtSwitch_.otherwiseopt_ = p4;
   tmp->u.stmtSwitch_.endswitch_    = p5;
   tmp->u.stmtSwitch_.stmtend_      = p6;
   return tmp;
}

/********************   StmtDoCase    ********************/

Stmt make_StmtDoCase( LineEol p1, CaseCondList p2, OtherwiseOpt p3, EndCase p4, StmtEnd p5 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtDoCase!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_StmtDoCase;
   tmp->u.stmtDoCase_.lineeol_      = p1;
   tmp->u.stmtDoCase_.casecondlist_ = p2;
   tmp->u.stmtDoCase_.otherwiseopt_ = p3;
   tmp->u.stmtDoCase_.endcase_      = p4;
   tmp->u.stmtDoCase_.stmtend_      = p5;
   return tmp;
}

/********************   StmtSequence    ********************/

Stmt make_StmtSequence( LineEol p1, StmtList p2, RecoverOpt p3, EndSequence p4, StmtEnd p5 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtSequence!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_StmtSequence;
   tmp->u.stmtSequence_.lineeol_     = p1;
   tmp->u.stmtSequence_.stmtlist_    = p2;
   tmp->u.stmtSequence_.recoveropt_  = p3;
   tmp->u.stmtSequence_.endsequence_ = p4;
   tmp->u.stmtSequence_.stmtend_     = p5;
   return tmp;
}

/********************   StmtBreak    ********************/

Stmt make_StmtBreak( BreakExprOpt p1, StmtEnd p2 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtBreak!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_StmtBreak;
   tmp->u.stmtBreak_.breakexpropt_ = p1;
   tmp->u.stmtBreak_.stmtend_      = p2;
   return tmp;
}

/********************   StmtExit    ********************/

Stmt make_StmtExit( StmtEnd p1 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtExit!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_StmtExit;
   tmp->u.stmtExit_.stmtend_ = p1;
   return tmp;
}

/********************   StmtLoop    ********************/

Stmt make_StmtLoop( StmtEnd p1 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtLoop!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_StmtLoop;
   tmp->u.stmtLoop_.stmtend_ = p1;
   return tmp;
}

/********************   StmtReturn    ********************/

Stmt make_StmtReturn( ReturnExprOpt p1, StmtEnd p2 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtReturn!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_StmtReturn;
   tmp->u.stmtReturn_.returnexpropt_ = p1;
   tmp->u.stmtReturn_.stmtend_       = p2;
   return tmp;
}

/********************   StmtStructDecl    ********************/

Stmt make_StmtStructDecl( StructDecl p1 )
{
   Stmt tmp = ( Stmt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtStructDecl!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_StmtStructDecl;
   tmp->u.stmtStructDecl_.structdecl_ = p1;
   return tmp;
}

/********************   ReturnExprOptEmpty    ********************/

ReturnExprOpt make_ReturnExprOptEmpty()
{
   ReturnExprOpt tmp = ( ReturnExprOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ReturnExprOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ReturnExprOptEmpty;
   return tmp;
}

/********************   ReturnExprOptSome    ********************/

ReturnExprOpt make_ReturnExprOptSome( Expr p1 )
{
   ReturnExprOpt tmp = ( ReturnExprOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ReturnExprOptSome!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_ReturnExprOptSome;
   tmp->u.returnExprOptSome_.expr_ = p1;
   return tmp;
}

/********************   ListStmtEmpty    ********************/

StmtList make_ListStmtEmpty()
{
   StmtList tmp = ( StmtList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListStmtEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListStmtEmpty;
   return tmp;
}

/********************   ListStmtCons    ********************/

StmtList make_ListStmtCons( Stmt p1, StmtList p2 )
{
   StmtList tmp = ( StmtList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListStmtCons!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_ListStmtCons;
   tmp->u.listStmtCons_.stmt_     = p1;
   tmp->u.listStmtCons_.stmtlist_ = p2;
   return tmp;
}

/********************   ListStmtLine    ********************/

StmtList make_ListStmtLine( LineEol p1, StmtList p2 )
{
   StmtList tmp = ( StmtList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListStmtLine!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_ListStmtLine;
   tmp->u.listStmtLine_.lineeol_  = p1;
   tmp->u.listStmtLine_.stmtlist_ = p2;
   return tmp;
}

/********************   ListStmtNonEmpty    ********************/

StmtListNonEmpty make_ListStmtNonEmpty( Stmt p1, StmtList p2 )
{
   StmtListNonEmpty tmp = ( StmtListNonEmpty ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListStmtNonEmpty!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_ListStmtNonEmpty;
   tmp->u.listStmtNonEmpty_.stmt_     = p1;
   tmp->u.listStmtNonEmpty_.stmtlist_ = p2;
   return tmp;
}

/********************   ListElseIfEmpty    ********************/

ElseIfList make_ListElseIfEmpty()
{
   ElseIfList tmp = ( ElseIfList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListElseIfEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListElseIfEmpty;
   return tmp;
}

/********************   ListElseIfCons    ********************/

ElseIfList make_ListElseIfCons( ElseIf p1, ElseIfList p2 )
{
   ElseIfList tmp = ( ElseIfList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListElseIfCons!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_ListElseIfCons;
   tmp->u.listElseIfCons_.elseif_     = p1;
   tmp->u.listElseIfCons_.elseiflist_ = p2;
   return tmp;
}

/********************   ElseIfClause    ********************/

ElseIf make_ElseIfClause( IfCond p1, LineEol p2, StmtList p3 )
{
   ElseIf tmp = ( ElseIf ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ElseIfClause!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_ElseIfClause;
   tmp->u.elseIfClause_.ifcond_   = p1;
   tmp->u.elseIfClause_.lineeol_  = p2;
   tmp->u.elseIfClause_.stmtlist_ = p3;
   return tmp;
}

/********************   OptElseEmpty    ********************/

ElseOpt make_OptElseEmpty()
{
   ElseOpt tmp = ( ElseOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptElseEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptElseEmpty;
   return tmp;
}

/********************   OptElseSome    ********************/

ElseOpt make_OptElseSome( LineEol p1, StmtList p2 )
{
   ElseOpt tmp = ( ElseOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptElseSome!\n" );
      exit( 1 );
   }
   tmp->kind                     = is_OptElseSome;
   tmp->u.optElseSome_.lineeol_  = p1;
   tmp->u.optElseSome_.stmtlist_ = p2;
   return tmp;
}

/********************   IfCondExpr    ********************/

IfCond make_IfCondExpr( Expr p1 )
{
   IfCond tmp = ( IfCond ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating IfCondExpr!\n" );
      exit( 1 );
   }
   tmp->kind                = is_IfCondExpr;
   tmp->u.ifCondExpr_.expr_ = p1;
   return tmp;
}

/********************   EndIfWord    ********************/

EndIf make_EndIfWord()
{
   EndIf tmp = ( EndIf ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndIfWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndIfWord;
   return tmp;
}

/********************   EndIfClause    ********************/

EndIf make_EndIfClause( EndIfOpt p1 )
{
   EndIf tmp = ( EndIf ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndIfClause!\n" );
      exit( 1 );
   }
   tmp->kind                     = is_EndIfClause;
   tmp->u.endIfClause_.endifopt_ = p1;
   return tmp;
}

/********************   EndIfOptEmpty    ********************/

EndIfOpt make_EndIfOptEmpty()
{
   EndIfOpt tmp = ( EndIfOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndIfOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndIfOptEmpty;
   return tmp;
}

/********************   EndIfOptIf    ********************/

EndIfOpt make_EndIfOptIf()
{
   EndIfOpt tmp = ( EndIfOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndIfOptIf!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndIfOptIf;
   return tmp;
}

/********************   DoOptEmpty    ********************/

DoOpt make_DoOptEmpty()
{
   DoOpt tmp = ( DoOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating DoOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_DoOptEmpty;
   return tmp;
}

/********************   DoOptDo    ********************/

DoOpt make_DoOptDo()
{
   DoOpt tmp = ( DoOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating DoOptDo!\n" );
      exit( 1 );
   }
   tmp->kind = is_DoOptDo;
   return tmp;
}

/********************   WhileCondExpr    ********************/

WhileCond make_WhileCondExpr( Expr p1 )
{
   WhileCond tmp = ( WhileCond ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating WhileCondExpr!\n" );
      exit( 1 );
   }
   tmp->kind                   = is_WhileCondExpr;
   tmp->u.whileCondExpr_.expr_ = p1;
   return tmp;
}

/********************   EndDoWord    ********************/

EndDo make_EndDoWord()
{
   EndDo tmp = ( EndDo ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndDoWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndDoWord;
   return tmp;
}

/********************   EndWhileWord    ********************/

EndDo make_EndWhileWord()
{
   EndDo tmp = ( EndDo ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndWhileWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndWhileWord;
   return tmp;
}

/********************   EndDoClause    ********************/

EndDo make_EndDoClause( EndDoOpt p1 )
{
   EndDo tmp = ( EndDo ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndDoClause!\n" );
      exit( 1 );
   }
   tmp->kind                     = is_EndDoClause;
   tmp->u.endDoClause_.enddoopt_ = p1;
   return tmp;
}

/********************   EndDoOptEmpty    ********************/

EndDoOpt make_EndDoOptEmpty()
{
   EndDoOpt tmp = ( EndDoOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndDoOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndDoOptEmpty;
   return tmp;
}

/********************   EndDoOptDo    ********************/

EndDoOpt make_EndDoOptDo()
{
   EndDoOpt tmp = ( EndDoOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndDoOptDo!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndDoOptDo;
   return tmp;
}

/********************   EndDoOptWhile    ********************/

EndDoOpt make_EndDoOptWhile()
{
   EndDoOpt tmp = ( EndDoOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndDoOptWhile!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndDoOptWhile;
   return tmp;
}

/********************   EndCaseWord    ********************/

EndCase make_EndCaseWord()
{
   EndCase tmp = ( EndCase ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndCaseWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndCaseWord;
   return tmp;
}

/********************   EndCaseClause    ********************/

EndCase make_EndCaseClause( EndCaseOpt p1 )
{
   EndCase tmp = ( EndCase ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndCaseClause!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_EndCaseClause;
   tmp->u.endCaseClause_.endcaseopt_ = p1;
   return tmp;
}

/********************   EndCaseOptEmpty    ********************/

EndCaseOpt make_EndCaseOptEmpty()
{
   EndCaseOpt tmp = ( EndCaseOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndCaseOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndCaseOptEmpty;
   return tmp;
}

/********************   EndCaseOptCase    ********************/

EndCaseOpt make_EndCaseOptCase()
{
   EndCaseOpt tmp = ( EndCaseOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndCaseOptCase!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndCaseOptCase;
   return tmp;
}

/********************   OptStepEmpty    ********************/

StepOpt make_OptStepEmpty()
{
   StepOpt tmp = ( StepOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptStepEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptStepEmpty;
   return tmp;
}

/********************   OptStepSome    ********************/

StepOpt make_OptStepSome( Expr p1 )
{
   StepOpt tmp = ( StepOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptStepSome!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_OptStepSome;
   tmp->u.optStepSome_.expr_ = p1;
   return tmp;
}

/********************   EndForWord    ********************/

EndFor make_EndForWord()
{
   EndFor tmp = ( EndFor ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndForWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndForWord;
   return tmp;
}

/********************   EndForClause    ********************/

EndFor make_EndForClause( EndForOpt p1 )
{
   EndFor tmp = ( EndFor ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndForClause!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_EndForClause;
   tmp->u.endForClause_.endforopt_ = p1;
   return tmp;
}

/********************   EndForOptEmpty    ********************/

EndForOpt make_EndForOptEmpty()
{
   EndForOpt tmp = ( EndForOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndForOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndForOptEmpty;
   return tmp;
}

/********************   EndForOptFor    ********************/

EndForOpt make_EndForOptFor()
{
   EndForOpt tmp = ( EndForOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndForOptFor!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndForOptFor;
   return tmp;
}

/********************   ForEachVarsMain    ********************/

ForEachVars make_ForEachVarsMain( Ident p1, ForEachVarsTail p2 )
{
   ForEachVars tmp = ( ForEachVars ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ForEachVarsMain!\n" );
      exit( 1 );
   }
   tmp->kind                                = is_ForEachVarsMain;
   tmp->u.forEachVarsMain_.ident_           = p1;
   tmp->u.forEachVarsMain_.foreachvarstail_ = p2;
   return tmp;
}

/********************   ListForEachVarsTailEmpty    ********************/

ForEachVarsTail make_ListForEachVarsTailEmpty()
{
   ForEachVarsTail tmp = ( ForEachVarsTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListForEachVarsTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListForEachVarsTailEmpty;
   return tmp;
}

/********************   ListForEachVarsTailCons    ********************/

ForEachVarsTail make_ListForEachVarsTailCons( Ident p1, ForEachVarsTail p2 )
{
   ForEachVarsTail tmp = ( ForEachVarsTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListForEachVarsTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                                        = is_ListForEachVarsTailCons;
   tmp->u.listForEachVarsTailCons_.ident_           = p1;
   tmp->u.listForEachVarsTailCons_.foreachvarstail_ = p2;
   return tmp;
}

/********************   ForEachExprsMain    ********************/

ForEachExprs make_ForEachExprsMain( Expr p1, ForEachExprsTail p2 )
{
   ForEachExprs tmp = ( ForEachExprs ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ForEachExprsMain!\n" );
      exit( 1 );
   }
   tmp->kind                                  = is_ForEachExprsMain;
   tmp->u.forEachExprsMain_.expr_             = p1;
   tmp->u.forEachExprsMain_.foreachexprstail_ = p2;
   return tmp;
}

/********************   ListForEachExprsTailEmpty    ********************/

ForEachExprsTail make_ListForEachExprsTailEmpty()
{
   ForEachExprsTail tmp = ( ForEachExprsTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListForEachExprsTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListForEachExprsTailEmpty;
   return tmp;
}

/********************   ListForEachExprsTailCons    ********************/

ForEachExprsTail make_ListForEachExprsTailCons( Expr p1, ForEachExprsTail p2 )
{
   ForEachExprsTail tmp = ( ForEachExprsTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListForEachExprsTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                                          = is_ListForEachExprsTailCons;
   tmp->u.listForEachExprsTailCons_.expr_             = p1;
   tmp->u.listForEachExprsTailCons_.foreachexprstail_ = p2;
   return tmp;
}

/********************   ForEachDescOptEmpty    ********************/

ForEachDescOpt make_ForEachDescOptEmpty()
{
   ForEachDescOpt tmp = ( ForEachDescOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ForEachDescOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ForEachDescOptEmpty;
   return tmp;
}

/********************   ForEachDescOptSome    ********************/

ForEachDescOpt make_ForEachDescOptSome()
{
   ForEachDescOpt tmp = ( ForEachDescOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ForEachDescOptSome!\n" );
      exit( 1 );
   }
   tmp->kind = is_ForEachDescOptSome;
   return tmp;
}

/********************   ListCaseEmpty    ********************/

CaseList make_ListCaseEmpty()
{
   CaseList tmp = ( CaseList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListCaseEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListCaseEmpty;
   return tmp;
}

/********************   ListCaseCons    ********************/

CaseList make_ListCaseCons( CaseClause p1, CaseList p2 )
{
   CaseList tmp = ( CaseList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListCaseCons!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_ListCaseCons;
   tmp->u.listCaseCons_.caseclause_ = p1;
   tmp->u.listCaseCons_.caselist_   = p2;
   return tmp;
}

/********************   CaseClauseItem    ********************/

CaseClause make_CaseClauseItem( CaseValue p1, LineEol p2, StmtList p3 )
{
   CaseClause tmp = ( CaseClause ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating CaseClauseItem!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_CaseClauseItem;
   tmp->u.caseClauseItem_.casevalue_ = p1;
   tmp->u.caseClauseItem_.lineeol_   = p2;
   tmp->u.caseClauseItem_.stmtlist_  = p3;
   return tmp;
}

/********************   ListCaseCondEmpty    ********************/

CaseCondList make_ListCaseCondEmpty()
{
   CaseCondList tmp = ( CaseCondList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListCaseCondEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListCaseCondEmpty;
   return tmp;
}

/********************   ListCaseCondCons    ********************/

CaseCondList make_ListCaseCondCons( CaseCondClause p1, CaseCondList p2 )
{
   CaseCondList tmp = ( CaseCondList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListCaseCondCons!\n" );
      exit( 1 );
   }
   tmp->kind                                = is_ListCaseCondCons;
   tmp->u.listCaseCondCons_.casecondclause_ = p1;
   tmp->u.listCaseCondCons_.casecondlist_   = p2;
   return tmp;
}

/********************   CaseCondClauseItem    ********************/

CaseCondClause make_CaseCondClauseItem( Expr p1, LineEol p2, StmtList p3 )
{
   CaseCondClause tmp = ( CaseCondClause ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating CaseCondClauseItem!\n" );
      exit( 1 );
   }
   tmp->kind                            = is_CaseCondClauseItem;
   tmp->u.caseCondClauseItem_.expr_     = p1;
   tmp->u.caseCondClauseItem_.lineeol_  = p2;
   tmp->u.caseCondClauseItem_.stmtlist_ = p3;
   return tmp;
}

/********************   OptOtherwiseEmpty    ********************/

OtherwiseOpt make_OptOtherwiseEmpty()
{
   OtherwiseOpt tmp = ( OtherwiseOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptOtherwiseEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptOtherwiseEmpty;
   return tmp;
}

/********************   OptOtherwiseSome    ********************/

OtherwiseOpt make_OptOtherwiseSome( LineEol p1, StmtList p2 )
{
   OtherwiseOpt tmp = ( OtherwiseOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptOtherwiseSome!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_OptOtherwiseSome;
   tmp->u.optOtherwiseSome_.lineeol_  = p1;
   tmp->u.optOtherwiseSome_.stmtlist_ = p2;
   return tmp;
}

/********************   BreakExprOptEmpty    ********************/

BreakExprOpt make_BreakExprOptEmpty()
{
   BreakExprOpt tmp = ( BreakExprOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating BreakExprOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_BreakExprOptEmpty;
   return tmp;
}

/********************   BreakExprOptSome    ********************/

BreakExprOpt make_BreakExprOptSome( Expr p1 )
{
   BreakExprOpt tmp = ( BreakExprOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating BreakExprOptSome!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_BreakExprOptSome;
   tmp->u.breakExprOptSome_.expr_ = p1;
   return tmp;
}

/********************   RecoverOptEmpty    ********************/

RecoverOpt make_RecoverOptEmpty()
{
   RecoverOpt tmp = ( RecoverOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating RecoverOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_RecoverOptEmpty;
   return tmp;
}

/********************   RecoverOptSome    ********************/

RecoverOpt make_RecoverOptSome( RecoverUsingOpt p1, LineEol p2, StmtList p3 )
{
   RecoverOpt tmp = ( RecoverOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating RecoverOptSome!\n" );
      exit( 1 );
   }
   tmp->kind                               = is_RecoverOptSome;
   tmp->u.recoverOptSome_.recoverusingopt_ = p1;
   tmp->u.recoverOptSome_.lineeol_         = p2;
   tmp->u.recoverOptSome_.stmtlist_        = p3;
   return tmp;
}

/********************   RecoverUsingOptEmpty    ********************/

RecoverUsingOpt make_RecoverUsingOptEmpty()
{
   RecoverUsingOpt tmp = ( RecoverUsingOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating RecoverUsingOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_RecoverUsingOptEmpty;
   return tmp;
}

/********************   RecoverUsingOptSome    ********************/

RecoverUsingOpt make_RecoverUsingOptSome( Ident p1 )
{
   RecoverUsingOpt tmp = ( RecoverUsingOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating RecoverUsingOptSome!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_RecoverUsingOptSome;
   tmp->u.recoverUsingOptSome_.ident_ = p1;
   return tmp;
}

/********************   EndSequenceWord    ********************/

EndSequence make_EndSequenceWord()
{
   EndSequence tmp = ( EndSequence ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndSequenceWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndSequenceWord;
   return tmp;
}

/********************   EndSequenceClause    ********************/

EndSequence make_EndSequenceClause( EndSequenceOpt p1 )
{
   EndSequence tmp = ( EndSequence ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndSequenceClause!\n" );
      exit( 1 );
   }
   tmp->kind                                 = is_EndSequenceClause;
   tmp->u.endSequenceClause_.endsequenceopt_ = p1;
   return tmp;
}

/********************   EndSequenceOptEmpty    ********************/

EndSequenceOpt make_EndSequenceOptEmpty()
{
   EndSequenceOpt tmp = ( EndSequenceOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndSequenceOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndSequenceOptEmpty;
   return tmp;
}

/********************   EndSequenceOptSeq    ********************/

EndSequenceOpt make_EndSequenceOptSeq()
{
   EndSequenceOpt tmp = ( EndSequenceOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndSequenceOptSeq!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndSequenceOptSeq;
   return tmp;
}

/********************   SwitchCondExpr    ********************/

SwitchCond make_SwitchCondExpr( Expr p1 )
{
   SwitchCond tmp = ( SwitchCond ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating SwitchCondExpr!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_SwitchCondExpr;
   tmp->u.switchCondExpr_.expr_ = p1;
   return tmp;
}

/********************   EndSwitchWord    ********************/

EndSwitch make_EndSwitchWord()
{
   EndSwitch tmp = ( EndSwitch ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndSwitchWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndSwitchWord;
   return tmp;
}

/********************   EndSwitchClause    ********************/

EndSwitch make_EndSwitchClause( EndSwitchOpt p1 )
{
   EndSwitch tmp = ( EndSwitch ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndSwitchClause!\n" );
      exit( 1 );
   }
   tmp->kind                             = is_EndSwitchClause;
   tmp->u.endSwitchClause_.endswitchopt_ = p1;
   return tmp;
}

/********************   EndSwitchOptEmpty    ********************/

EndSwitchOpt make_EndSwitchOptEmpty()
{
   EndSwitchOpt tmp = ( EndSwitchOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndSwitchOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndSwitchOptEmpty;
   return tmp;
}

/********************   EndSwitchOptSwitch    ********************/

EndSwitchOpt make_EndSwitchOptSwitch()
{
   EndSwitchOpt tmp = ( EndSwitchOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndSwitchOptSwitch!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndSwitchOptSwitch;
   return tmp;
}

/********************   EndStructWord    ********************/

EndStruct make_EndStructWord()
{
   EndStruct tmp = ( EndStruct ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndStructWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndStructWord;
   return tmp;
}

/********************   EndStructClause    ********************/

EndStruct make_EndStructClause( EndStructOpt p1 )
{
   EndStruct tmp = ( EndStruct ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndStructClause!\n" );
      exit( 1 );
   }
   tmp->kind                             = is_EndStructClause;
   tmp->u.endStructClause_.endstructopt_ = p1;
   return tmp;
}

/********************   EndStructOptEmpty    ********************/

EndStructOpt make_EndStructOptEmpty()
{
   EndStructOpt tmp = ( EndStructOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndStructOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndStructOptEmpty;
   return tmp;
}

/********************   EndStructOptStruct    ********************/

EndStructOpt make_EndStructOptStruct()
{
   EndStructOpt tmp = ( EndStructOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndStructOptStruct!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndStructOptStruct;
   return tmp;
}

/********************   EndClassWord    ********************/

EndClass make_EndClassWord()
{
   EndClass tmp = ( EndClass ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndClassWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndClassWord;
   return tmp;
}

/********************   EndClassClause    ********************/

EndClass make_EndClassClause( EndClassOpt p1 )
{
   EndClass tmp = ( EndClass ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndClassClause!\n" );
      exit( 1 );
   }
   tmp->kind                           = is_EndClassClause;
   tmp->u.endClassClause_.endclassopt_ = p1;
   return tmp;
}

/********************   EndClassOptEmpty    ********************/

EndClassOpt make_EndClassOptEmpty()
{
   EndClassOpt tmp = ( EndClassOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndClassOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndClassOptEmpty;
   return tmp;
}

/********************   EndClassOptClass    ********************/

EndClassOpt make_EndClassOptClass()
{
   EndClassOpt tmp = ( EndClassOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndClassOptClass!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndClassOptClass;
   return tmp;
}

/********************   EndEnumWord    ********************/

EndEnum make_EndEnumWord()
{
   EndEnum tmp = ( EndEnum ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndEnumWord!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndEnumWord;
   return tmp;
}

/********************   EndEnumClause    ********************/

EndEnum make_EndEnumClause( EndEnumOpt p1 )
{
   EndEnum tmp = ( EndEnum ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndEnumClause!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_EndEnumClause;
   tmp->u.endEnumClause_.endenumopt_ = p1;
   return tmp;
}

/********************   EndEnumOptEmpty    ********************/

EndEnumOpt make_EndEnumOptEmpty()
{
   EndEnumOpt tmp = ( EndEnumOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndEnumOptEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndEnumOptEmpty;
   return tmp;
}

/********************   EndEnumOptEnum    ********************/

EndEnumOpt make_EndEnumOptEnum()
{
   EndEnumOpt tmp = ( EndEnumOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EndEnumOptEnum!\n" );
      exit( 1 );
   }
   tmp->kind = is_EndEnumOptEnum;
   return tmp;
}

/********************   CaseValueInt    ********************/

CaseValue make_CaseValueInt( IntLit p1 )
{
   CaseValue tmp = ( CaseValue ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating CaseValueInt!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_CaseValueInt;
   tmp->u.caseValueInt_.intlit_ = p1;
   return tmp;
}

/********************   CaseValueStr    ********************/

CaseValue make_CaseValueStr( Napis p1 )
{
   CaseValue tmp = ( CaseValue ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating CaseValueStr!\n" );
      exit( 1 );
   }
   tmp->kind                   = is_CaseValueStr;
   tmp->u.caseValueStr_.napis_ = p1;
   return tmp;
}

/********************   StmtEndLine    ********************/

StmtEnd make_StmtEndLine( LineEol p1 )
{
   StmtEnd tmp = ( StmtEnd ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StmtEndLine!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_StmtEndLine;
   tmp->u.stmtEndLine_.lineeol_ = p1;
   return tmp;
}

/********************   EnumDeclNamed    ********************/

EnumDecl make_EnumDeclNamed( Ident p1, LineEol p2, EnumListOpt p3, EndEnum p4, StmtEnd p5 )
{
   EnumDecl tmp = ( EnumDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EnumDeclNamed!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_EnumDeclNamed;
   tmp->u.enumDeclNamed_.ident_       = p1;
   tmp->u.enumDeclNamed_.lineeol_     = p2;
   tmp->u.enumDeclNamed_.enumlistopt_ = p3;
   tmp->u.enumDeclNamed_.endenum_     = p4;
   tmp->u.enumDeclNamed_.stmtend_     = p5;
   return tmp;
}

/********************   EnumDeclAnon    ********************/

EnumDecl make_EnumDeclAnon( LineEol p1, EnumListOpt p2, EndEnum p3, StmtEnd p4 )
{
   EnumDecl tmp = ( EnumDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EnumDeclAnon!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_EnumDeclAnon;
   tmp->u.enumDeclAnon_.lineeol_     = p1;
   tmp->u.enumDeclAnon_.enumlistopt_ = p2;
   tmp->u.enumDeclAnon_.endenum_     = p3;
   tmp->u.enumDeclAnon_.stmtend_     = p4;
   return tmp;
}

/********************   OptEnumListEmpty    ********************/

EnumListOpt make_OptEnumListEmpty()
{
   EnumListOpt tmp = ( EnumListOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptEnumListEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptEnumListEmpty;
   return tmp;
}

/********************   OptEnumListSome    ********************/

EnumListOpt make_OptEnumListSome( EnumItem p1, EnumListTail p2 )
{
   EnumListOpt tmp = ( EnumListOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptEnumListSome!\n" );
      exit( 1 );
   }
   tmp->kind                             = is_OptEnumListSome;
   tmp->u.optEnumListSome_.enumitem_     = p1;
   tmp->u.optEnumListSome_.enumlisttail_ = p2;
   return tmp;
}

/********************   ListEnumTailEmpty    ********************/

EnumListTail make_ListEnumTailEmpty()
{
   EnumListTail tmp = ( EnumListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListEnumTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListEnumTailEmpty;
   return tmp;
}

/********************   ListEnumTailCons    ********************/

EnumListTail make_ListEnumTailCons( EnumSep p1, EnumItem p2, EnumListTail p3 )
{
   EnumListTail tmp = ( EnumListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListEnumTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                              = is_ListEnumTailCons;
   tmp->u.listEnumTailCons_.enumsep_      = p1;
   tmp->u.listEnumTailCons_.enumitem_     = p2;
   tmp->u.listEnumTailCons_.enumlisttail_ = p3;
   return tmp;
}

/********************   ListEnumTailSep    ********************/

EnumListTail make_ListEnumTailSep( EnumSep p1 )
{
   EnumListTail tmp = ( EnumListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListEnumTailSep!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_ListEnumTailSep;
   tmp->u.listEnumTailSep_.enumsep_ = p1;
   return tmp;
}

/********************   EnumSepComma    ********************/

EnumSep make_EnumSepComma( LineEolOpt p1 )
{
   EnumSep tmp = ( EnumSep ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EnumSepComma!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_EnumSepComma;
   tmp->u.enumSepComma_.lineeolopt_ = p1;
   return tmp;
}

/********************   EnumSepLine    ********************/

EnumSep make_EnumSepLine( LineEol p1 )
{
   EnumSep tmp = ( EnumSep ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EnumSepLine!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_EnumSepLine;
   tmp->u.enumSepLine_.lineeol_ = p1;
   return tmp;
}

/********************   EnumItemDecl    ********************/

EnumItem make_EnumItemDecl( Ident p1, EnumValueOpt p2 )
{
   EnumItem tmp = ( EnumItem ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating EnumItemDecl!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_EnumItemDecl;
   tmp->u.enumItemDecl_.ident_        = p1;
   tmp->u.enumItemDecl_.enumvalueopt_ = p2;
   return tmp;
}

/********************   OptEnumValueEmpty    ********************/

EnumValueOpt make_OptEnumValueEmpty()
{
   EnumValueOpt tmp = ( EnumValueOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptEnumValueEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptEnumValueEmpty;
   return tmp;
}

/********************   OptEnumValueSome    ********************/

EnumValueOpt make_OptEnumValueSome( IntLit p1 )
{
   EnumValueOpt tmp = ( EnumValueOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptEnumValueSome!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_OptEnumValueSome;
   tmp->u.optEnumValueSome_.intlit_ = p1;
   return tmp;
}

/********************   OptLineEolEmpty    ********************/

LineEolOpt make_OptLineEolEmpty()
{
   LineEolOpt tmp = ( LineEolOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptLineEolEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptLineEolEmpty;
   return tmp;
}

/********************   OptLineEolSome    ********************/

LineEolOpt make_OptLineEolSome( LineEol p1 )
{
   LineEolOpt tmp = ( LineEolOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptLineEolSome!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_OptLineEolSome;
   tmp->u.optLineEolSome_.lineeol_ = p1;
   return tmp;
}

/********************   StructDeclMain    ********************/

StructDecl make_StructDeclMain( Ident p1, LineEol p2, StructBody p3, EndStruct p4, StmtEnd p5 )
{
   StructDecl tmp = ( StructDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StructDeclMain!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_StructDeclMain;
   tmp->u.structDeclMain_.ident_      = p1;
   tmp->u.structDeclMain_.lineeol_    = p2;
   tmp->u.structDeclMain_.structbody_ = p3;
   tmp->u.structDeclMain_.endstruct_  = p4;
   tmp->u.structDeclMain_.stmtend_    = p5;
   return tmp;
}

/********************   StructBodyEmpty    ********************/

StructBody make_StructBodyEmpty()
{
   StructBody tmp = ( StructBody ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StructBodyEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_StructBodyEmpty;
   return tmp;
}

/********************   StructBodyCons    ********************/

StructBody make_StructBodyCons( StructMember p1, StructBody p2 )
{
   StructBody tmp = ( StructBody ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StructBodyCons!\n" );
      exit( 1 );
   }
   tmp->kind                            = is_StructBodyCons;
   tmp->u.structBodyCons_.structmember_ = p1;
   tmp->u.structBodyCons_.structbody_   = p2;
   return tmp;
}

/********************   StructMemberVar    ********************/

StructMember make_StructMemberVar( VarList p1, LineEol p2 )
{
   StructMember tmp = ( StructMember ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StructMemberVar!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_StructMemberVar;
   tmp->u.structMemberVar_.varlist_ = p1;
   tmp->u.structMemberVar_.lineeol_ = p2;
   return tmp;
}

/********************   FieldInitListSingle    ********************/

FieldInitList make_FieldInitListSingle( FieldInit p1 )
{
   FieldInitList tmp = ( FieldInitList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating FieldInitListSingle!\n" );
      exit( 1 );
   }
   tmp->kind                              = is_FieldInitListSingle;
   tmp->u.fieldInitListSingle_.fieldinit_ = p1;
   return tmp;
}

/********************   FieldInitListCons    ********************/

FieldInitList make_FieldInitListCons( FieldInit p1, FieldInitList p2 )
{
   FieldInitList tmp = ( FieldInitList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating FieldInitListCons!\n" );
      exit( 1 );
   }
   tmp->kind                                = is_FieldInitListCons;
   tmp->u.fieldInitListCons_.fieldinit_     = p1;
   tmp->u.fieldInitListCons_.fieldinitlist_ = p2;
   return tmp;
}

/********************   FieldInitItem    ********************/

FieldInit make_FieldInitItem( Ident p1, Expr p2 )
{
   FieldInit tmp = ( FieldInit ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating FieldInitItem!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_FieldInitItem;
   tmp->u.fieldInitItem_.ident_ = p1;
   tmp->u.fieldInitItem_.expr_  = p2;
   return tmp;
}

/********************   StaticStructDecl    ********************/

StaticDecl make_StaticStructDecl( Ident p1, IdentInitList p2, StmtEnd p3 )
{
   StaticDecl tmp = ( StaticDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticStructDecl!\n" );
      exit( 1 );
   }
   tmp->kind                               = is_StaticStructDecl;
   tmp->u.staticStructDecl_.ident_         = p1;
   tmp->u.staticStructDecl_.identinitlist_ = p2;
   tmp->u.staticStructDecl_.stmtend_       = p3;
   return tmp;
}

/********************   StaticDeclItem    ********************/

StaticDecl make_StaticDeclItem( StaticItemList p1, StmtEnd p2 )
{
   StaticDecl tmp = ( StaticDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticDeclItem!\n" );
      exit( 1 );
   }
   tmp->kind                              = is_StaticDeclItem;
   tmp->u.staticDeclItem_.staticitemlist_ = p1;
   tmp->u.staticDeclItem_.stmtend_        = p2;
   return tmp;
}

/********************   ClassDeclMain    ********************/

ClassDecl make_ClassDeclMain( CreateOpt p1, ClassName p2, InheritOpt p3, StaticClassOpt p4, LineEol p5, ClassBody p6,
                              EndClass p7, StmtEnd p8 )
{
   ClassDecl tmp = ( ClassDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ClassDeclMain!\n" );
      exit( 1 );
   }
   tmp->kind                             = is_ClassDeclMain;
   tmp->u.classDeclMain_.createopt_      = p1;
   tmp->u.classDeclMain_.classname_      = p2;
   tmp->u.classDeclMain_.inheritopt_     = p3;
   tmp->u.classDeclMain_.staticclassopt_ = p4;
   tmp->u.classDeclMain_.lineeol_        = p5;
   tmp->u.classDeclMain_.classbody_      = p6;
   tmp->u.classDeclMain_.endclass_       = p7;
   tmp->u.classDeclMain_.stmtend_        = p8;
   return tmp;
}

/********************   OptCreateEmpty    ********************/

CreateOpt make_OptCreateEmpty()
{
   CreateOpt tmp = ( CreateOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptCreateEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptCreateEmpty;
   return tmp;
}

/********************   OptCreateSome    ********************/

CreateOpt make_OptCreateSome()
{
   CreateOpt tmp = ( CreateOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptCreateSome!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptCreateSome;
   return tmp;
}

/********************   ClassNameIdent    ********************/

ClassName make_ClassNameIdent( Ident p1 )
{
   ClassName tmp = ( ClassName ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ClassNameIdent!\n" );
      exit( 1 );
   }
   tmp->kind                     = is_ClassNameIdent;
   tmp->u.classNameIdent_.ident_ = p1;
   return tmp;
}

/********************   OptInheritEmpty    ********************/

InheritOpt make_OptInheritEmpty()
{
   InheritOpt tmp = ( InheritOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptInheritEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptInheritEmpty;
   return tmp;
}

/********************   OptInheritSome    ********************/

InheritOpt make_OptInheritSome( InheritKeyword p1, ClassName p2 )
{
   InheritOpt tmp = ( InheritOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptInheritSome!\n" );
      exit( 1 );
   }
   tmp->kind                              = is_OptInheritSome;
   tmp->u.optInheritSome_.inheritkeyword_ = p1;
   tmp->u.optInheritSome_.classname_      = p2;
   return tmp;
}

/********************   InheritFrom    ********************/

InheritKeyword make_InheritFrom()
{
   InheritKeyword tmp = ( InheritKeyword ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating InheritFrom!\n" );
      exit( 1 );
   }
   tmp->kind = is_InheritFrom;
   return tmp;
}

/********************   InheritInherit    ********************/

InheritKeyword make_InheritInherit()
{
   InheritKeyword tmp = ( InheritKeyword ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating InheritInherit!\n" );
      exit( 1 );
   }
   tmp->kind = is_InheritInherit;
   return tmp;
}

/********************   OptStaticClassEmpty    ********************/

StaticClassOpt make_OptStaticClassEmpty()
{
   StaticClassOpt tmp = ( StaticClassOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptStaticClassEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptStaticClassEmpty;
   return tmp;
}

/********************   OptStaticClassSome    ********************/

StaticClassOpt make_OptStaticClassSome()
{
   StaticClassOpt tmp = ( StaticClassOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptStaticClassSome!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptStaticClassSome;
   return tmp;
}

/********************   ClassBodyEmpty    ********************/

ClassBody make_ClassBodyEmpty()
{
   ClassBody tmp = ( ClassBody ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ClassBodyEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ClassBodyEmpty;
   return tmp;
}

/********************   ClassBodyCons    ********************/

ClassBody make_ClassBodyCons( ClassMember p1, ClassBody p2 )
{
   ClassBody tmp = ( ClassBody ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ClassBodyCons!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_ClassBodyCons;
   tmp->u.classBodyCons_.classmember_ = p1;
   tmp->u.classBodyCons_.classbody_   = p2;
   return tmp;
}

/********************   ClassMemberVisibility    ********************/

ClassMember make_ClassMemberVisibility( VisibilityScope p1, LineEol p2 )
{
   ClassMember tmp = ( ClassMember ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ClassMemberVisibility!\n" );
      exit( 1 );
   }
   tmp->kind                                      = is_ClassMemberVisibility;
   tmp->u.classMemberVisibility_.visibilityscope_ = p1;
   tmp->u.classMemberVisibility_.lineeol_         = p2;
   return tmp;
}

/********************   ClassMemberVar    ********************/

ClassMember make_ClassMemberVar( VarList p1, LineEol p2 )
{
   ClassMember tmp = ( ClassMember ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ClassMemberVar!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_ClassMemberVar;
   tmp->u.classMemberVar_.varlist_ = p1;
   tmp->u.classMemberVar_.lineeol_ = p2;
   return tmp;
}

/********************   ClassMemberMethod    ********************/

ClassMember make_ClassMemberMethod( Ident p1, MethodParamsOpt p2, LineEol p3 )
{
   ClassMember tmp = ( ClassMember ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ClassMemberMethod!\n" );
      exit( 1 );
   }
   tmp->kind                                  = is_ClassMemberMethod;
   tmp->u.classMemberMethod_.ident_           = p1;
   tmp->u.classMemberMethod_.methodparamsopt_ = p2;
   tmp->u.classMemberMethod_.lineeol_         = p3;
   return tmp;
}

/********************   VisibilityExported    ********************/

VisibilityScope make_VisibilityExported()
{
   VisibilityScope tmp = ( VisibilityScope ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating VisibilityExported!\n" );
      exit( 1 );
   }
   tmp->kind = is_VisibilityExported;
   return tmp;
}

/********************   VisibilityVisible    ********************/

VisibilityScope make_VisibilityVisible()
{
   VisibilityScope tmp = ( VisibilityScope ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating VisibilityVisible!\n" );
      exit( 1 );
   }
   tmp->kind = is_VisibilityVisible;
   return tmp;
}

/********************   VisibilityHidden    ********************/

VisibilityScope make_VisibilityHidden()
{
   VisibilityScope tmp = ( VisibilityScope ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating VisibilityHidden!\n" );
      exit( 1 );
   }
   tmp->kind = is_VisibilityHidden;
   return tmp;
}

/********************   VisibilityProtected    ********************/

VisibilityScope make_VisibilityProtected()
{
   VisibilityScope tmp = ( VisibilityScope ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating VisibilityProtected!\n" );
      exit( 1 );
   }
   tmp->kind = is_VisibilityProtected;
   return tmp;
}

/********************   VarListSingle    ********************/

VarList make_VarListSingle( VarDecl p1 )
{
   VarList tmp = ( VarList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating VarListSingle!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_VarListSingle;
   tmp->u.varListSingle_.vardecl_ = p1;
   return tmp;
}

/********************   VarListCons    ********************/

VarList make_VarListCons( VarDecl p1, VarList p2 )
{
   VarList tmp = ( VarList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating VarListCons!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_VarListCons;
   tmp->u.varListCons_.vardecl_ = p1;
   tmp->u.varListCons_.varlist_ = p2;
   return tmp;
}

/********************   VarDeclItem    ********************/

VarDecl make_VarDeclItem( Ident p1, VarInitOpt p2 )
{
   VarDecl tmp = ( VarDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating VarDeclItem!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_VarDeclItem;
   tmp->u.varDeclItem_.ident_      = p1;
   tmp->u.varDeclItem_.varinitopt_ = p2;
   return tmp;
}

/********************   OptVarInitEmpty    ********************/

VarInitOpt make_OptVarInitEmpty()
{
   VarInitOpt tmp = ( VarInitOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptVarInitEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptVarInitEmpty;
   return tmp;
}

/********************   OptVarInitSome    ********************/

VarInitOpt make_OptVarInitSome( Expr p1 )
{
   VarInitOpt tmp = ( VarInitOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptVarInitSome!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_OptVarInitSome;
   tmp->u.optVarInitSome_.expr_ = p1;
   return tmp;
}

/********************   MethodParamsEmpty    ********************/

MethodParamsOpt make_MethodParamsEmpty()
{
   MethodParamsOpt tmp = ( MethodParamsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating MethodParamsEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_MethodParamsEmpty;
   return tmp;
}

/********************   MethodParamsSome    ********************/

MethodParamsOpt make_MethodParamsSome( ParamListOpt p1 )
{
   MethodParamsOpt tmp = ( MethodParamsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating MethodParamsSome!\n" );
      exit( 1 );
   }
   tmp->kind                              = is_MethodParamsSome;
   tmp->u.methodParamsSome_.paramlistopt_ = p1;
   return tmp;
}

/********************   ExprAssignBase    ********************/

Expr make_ExprAssignBase( ExprOr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprAssignBase!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_ExprAssignBase;
   tmp->u.exprAssignBase_.expror_ = p1;
   return tmp;
}

/********************   ExprAndDot    ********************/

Expr make_ExprAndDot( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprAndDot!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprAndDot;
   tmp->u.exprAndDot_.expr_1 = p1;
   tmp->u.exprAndDot_.expr_2 = p2;
   return tmp;
}

/********************   ExprAndBase    ********************/

Expr make_ExprAndBase( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprAndBase!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprAndBase;
   tmp->u.exprAndBase_.expr_ = p1;
   return tmp;
}

/********************   ExprNotDot    ********************/

Expr make_ExprNotDot( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprNotDot!\n" );
      exit( 1 );
   }
   tmp->kind                = is_ExprNotDot;
   tmp->u.exprNotDot_.expr_ = p1;
   return tmp;
}

/********************   ExprNotBase    ********************/

Expr make_ExprNotBase( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprNotBase!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprNotBase;
   tmp->u.exprNotBase_.expr_ = p1;
   return tmp;
}

/********************   ExprEq    ********************/

Expr make_ExprEq( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprEq!\n" );
      exit( 1 );
   }
   tmp->kind             = is_ExprEq;
   tmp->u.exprEq_.expr_1 = p1;
   tmp->u.exprEq_.expr_2 = p2;
   return tmp;
}

/********************   ExprEq2    ********************/

Expr make_ExprEq2( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprEq2!\n" );
      exit( 1 );
   }
   tmp->kind              = is_ExprEq2;
   tmp->u.exprEq2_.expr_1 = p1;
   tmp->u.exprEq2_.expr_2 = p2;
   return tmp;
}

/********************   ExprNeq    ********************/

Expr make_ExprNeq( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprNeq!\n" );
      exit( 1 );
   }
   tmp->kind              = is_ExprNeq;
   tmp->u.exprNeq_.expr_1 = p1;
   tmp->u.exprNeq_.expr_2 = p2;
   return tmp;
}

/********************   ExprNeq2    ********************/

Expr make_ExprNeq2( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprNeq2!\n" );
      exit( 1 );
   }
   tmp->kind               = is_ExprNeq2;
   tmp->u.exprNeq2_.expr_1 = p1;
   tmp->u.exprNeq2_.expr_2 = p2;
   return tmp;
}

/********************   ExprNeq3    ********************/

Expr make_ExprNeq3( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprNeq3!\n" );
      exit( 1 );
   }
   tmp->kind               = is_ExprNeq3;
   tmp->u.exprNeq3_.expr_1 = p1;
   tmp->u.exprNeq3_.expr_2 = p2;
   return tmp;
}

/********************   ExprLt    ********************/

Expr make_ExprLt( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprLt!\n" );
      exit( 1 );
   }
   tmp->kind             = is_ExprLt;
   tmp->u.exprLt_.expr_1 = p1;
   tmp->u.exprLt_.expr_2 = p2;
   return tmp;
}

/********************   ExprLe    ********************/

Expr make_ExprLe( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprLe!\n" );
      exit( 1 );
   }
   tmp->kind             = is_ExprLe;
   tmp->u.exprLe_.expr_1 = p1;
   tmp->u.exprLe_.expr_2 = p2;
   return tmp;
}

/********************   ExprGt    ********************/

Expr make_ExprGt( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprGt!\n" );
      exit( 1 );
   }
   tmp->kind             = is_ExprGt;
   tmp->u.exprGt_.expr_1 = p1;
   tmp->u.exprGt_.expr_2 = p2;
   return tmp;
}

/********************   ExprGe    ********************/

Expr make_ExprGe( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprGe!\n" );
      exit( 1 );
   }
   tmp->kind             = is_ExprGe;
   tmp->u.exprGe_.expr_1 = p1;
   tmp->u.exprGe_.expr_2 = p2;
   return tmp;
}

/********************   ExprSubStr    ********************/

Expr make_ExprSubStr( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprSubStr!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprSubStr;
   tmp->u.exprSubStr_.expr_1 = p1;
   tmp->u.exprSubStr_.expr_2 = p2;
   return tmp;
}

/********************   ExprRelBase    ********************/

Expr make_ExprRelBase( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprRelBase!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprRelBase;
   tmp->u.exprRelBase_.expr_ = p1;
   return tmp;
}

/********************   ExprAdd    ********************/

Expr make_ExprAdd( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprAdd!\n" );
      exit( 1 );
   }
   tmp->kind              = is_ExprAdd;
   tmp->u.exprAdd_.expr_1 = p1;
   tmp->u.exprAdd_.expr_2 = p2;
   return tmp;
}

/********************   ExprSub    ********************/

Expr make_ExprSub( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprSub!\n" );
      exit( 1 );
   }
   tmp->kind              = is_ExprSub;
   tmp->u.exprSub_.expr_1 = p1;
   tmp->u.exprSub_.expr_2 = p2;
   return tmp;
}

/********************   ExprAddBase    ********************/

Expr make_ExprAddBase( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprAddBase!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprAddBase;
   tmp->u.exprAddBase_.expr_ = p1;
   return tmp;
}

/********************   ExprMul    ********************/

Expr make_ExprMul( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprMul!\n" );
      exit( 1 );
   }
   tmp->kind              = is_ExprMul;
   tmp->u.exprMul_.expr_1 = p1;
   tmp->u.exprMul_.expr_2 = p2;
   return tmp;
}

/********************   ExprDiv    ********************/

Expr make_ExprDiv( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprDiv!\n" );
      exit( 1 );
   }
   tmp->kind              = is_ExprDiv;
   tmp->u.exprDiv_.expr_1 = p1;
   tmp->u.exprDiv_.expr_2 = p2;
   return tmp;
}

/********************   ExprMod    ********************/

Expr make_ExprMod( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprMod!\n" );
      exit( 1 );
   }
   tmp->kind              = is_ExprMod;
   tmp->u.exprMod_.expr_1 = p1;
   tmp->u.exprMod_.expr_2 = p2;
   return tmp;
}

/********************   ExprMulBase    ********************/

Expr make_ExprMulBase( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprMulBase!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprMulBase;
   tmp->u.exprMulBase_.expr_ = p1;
   return tmp;
}

/********************   ExprPow1    ********************/

Expr make_ExprPow1( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprPow1!\n" );
      exit( 1 );
   }
   tmp->kind               = is_ExprPow1;
   tmp->u.exprPow1_.expr_1 = p1;
   tmp->u.exprPow1_.expr_2 = p2;
   return tmp;
}

/********************   ExprPow2    ********************/

Expr make_ExprPow2( Expr p1, Expr p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprPow2!\n" );
      exit( 1 );
   }
   tmp->kind               = is_ExprPow2;
   tmp->u.exprPow2_.expr_1 = p1;
   tmp->u.exprPow2_.expr_2 = p2;
   return tmp;
}

/********************   ExprPowBase    ********************/

Expr make_ExprPowBase( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprPowBase!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprPowBase;
   tmp->u.exprPowBase_.expr_ = p1;
   return tmp;
}

/********************   ExprAddrOf    ********************/

Expr make_ExprAddrOf( LHS p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprAddrOf!\n" );
      exit( 1 );
   }
   tmp->kind               = is_ExprAddrOf;
   tmp->u.exprAddrOf_.lhs_ = p1;
   return tmp;
}

/********************   ExprDeref    ********************/

Expr make_ExprDeref( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprDeref!\n" );
      exit( 1 );
   }
   tmp->kind               = is_ExprDeref;
   tmp->u.exprDeref_.expr_ = p1;
   return tmp;
}

/********************   ExprDecPre    ********************/

Expr make_ExprDecPre( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprDecPre!\n" );
      exit( 1 );
   }
   tmp->kind                = is_ExprDecPre;
   tmp->u.exprDecPre_.expr_ = p1;
   return tmp;
}

/********************   ExprIncPre    ********************/

Expr make_ExprIncPre( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprIncPre!\n" );
      exit( 1 );
   }
   tmp->kind                = is_ExprIncPre;
   tmp->u.exprIncPre_.expr_ = p1;
   return tmp;
}

/********************   ExprPlus    ********************/

Expr make_ExprPlus( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprPlus!\n" );
      exit( 1 );
   }
   tmp->kind              = is_ExprPlus;
   tmp->u.exprPlus_.expr_ = p1;
   return tmp;
}

/********************   ExprMinus    ********************/

Expr make_ExprMinus( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprMinus!\n" );
      exit( 1 );
   }
   tmp->kind               = is_ExprMinus;
   tmp->u.exprMinus_.expr_ = p1;
   return tmp;
}

/********************   ExprSignBase    ********************/

Expr make_ExprSignBase( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprSignBase!\n" );
      exit( 1 );
   }
   tmp->kind                  = is_ExprSignBase;
   tmp->u.exprSignBase_.expr_ = p1;
   return tmp;
}

/********************   ExprLit    ********************/

Expr make_ExprLit( Literal p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprLit!\n" );
      exit( 1 );
   }
   tmp->kind                = is_ExprLit;
   tmp->u.exprLit_.literal_ = p1;
   return tmp;
}

/********************   ExprCall    ********************/

Expr make_ExprCall( CallExpr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprCall!\n" );
      exit( 1 );
   }
   tmp->kind                  = is_ExprCall;
   tmp->u.exprCall_.callexpr_ = p1;
   return tmp;
}

/********************   ExprQId    ********************/

Expr make_ExprQId( QualifiedId p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprQId!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_ExprQId;
   tmp->u.exprQId_.qualifiedid_ = p1;
   return tmp;
}

/********************   ExprParen    ********************/

Expr make_ExprParen( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprParen!\n" );
      exit( 1 );
   }
   tmp->kind               = is_ExprParen;
   tmp->u.exprParen_.expr_ = p1;
   return tmp;
}

/********************   ExprIndex    ********************/

Expr make_ExprIndex( Expr p1, SubscriptList p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprIndex!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_ExprIndex;
   tmp->u.exprIndex_.expr_          = p1;
   tmp->u.exprIndex_.subscriptlist_ = p2;
   return tmp;
}

/********************   ExprArray    ********************/

Expr make_ExprArray( ExprListOpt p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprArray!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_ExprArray;
   tmp->u.exprArray_.exprlistopt_ = p1;
   return tmp;
}

/********************   ExprBlock    ********************/

Expr make_ExprBlock( ParamListOpt p1, ExprListOpt p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprBlock!\n" );
      exit( 1 );
   }
   tmp->kind                       = is_ExprBlock;
   tmp->u.exprBlock_.paramlistopt_ = p1;
   tmp->u.exprBlock_.exprlistopt_  = p2;
   return tmp;
}

/********************   ExprMethodCall    ********************/

Expr make_ExprMethodCall( Expr p1, Ident p2, ArgListOpt p3 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprMethodCall!\n" );
      exit( 1 );
   }
   tmp->kind                          = is_ExprMethodCall;
   tmp->u.exprMethodCall_.expr_       = p1;
   tmp->u.exprMethodCall_.ident_      = p2;
   tmp->u.exprMethodCall_.arglistopt_ = p3;
   return tmp;
}

/********************   ExprFieldAccess    ********************/

Expr make_ExprFieldAccess( Expr p1, Ident p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprFieldAccess!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_ExprFieldAccess;
   tmp->u.exprFieldAccess_.expr_  = p1;
   tmp->u.exprFieldAccess_.ident_ = p2;
   return tmp;
}

/********************   ExprStructInitNamed    ********************/

Expr make_ExprStructInitNamed( QualifiedId p1, FieldInitList p2 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprStructInitNamed!\n" );
      exit( 1 );
   }
   tmp->kind                                  = is_ExprStructInitNamed;
   tmp->u.exprStructInitNamed_.qualifiedid_   = p1;
   tmp->u.exprStructInitNamed_.fieldinitlist_ = p2;
   return tmp;
}

/********************   ExprStructAnon    ********************/

Expr make_ExprStructAnon( FieldInitList p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprStructAnon!\n" );
      exit( 1 );
   }
   tmp->kind                             = is_ExprStructAnon;
   tmp->u.exprStructAnon_.fieldinitlist_ = p1;
   return tmp;
}

/********************   ExprDecPost    ********************/

Expr make_ExprDecPost( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprDecPost!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprDecPost;
   tmp->u.exprDecPost_.expr_ = p1;
   return tmp;
}

/********************   ExprIncPost    ********************/

Expr make_ExprIncPost( Expr p1 )
{
   Expr tmp = ( Expr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprIncPost!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprIncPost;
   tmp->u.exprIncPost_.expr_ = p1;
   return tmp;
}

/********************   ExprOrDot    ********************/

ExprOr make_ExprOrDot( ExprOr p1, Expr p2 )
{
   ExprOr tmp = ( ExprOr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprOrDot!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_ExprOrDot;
   tmp->u.exprOrDot_.expror_ = p1;
   tmp->u.exprOrDot_.expr_   = p2;
   return tmp;
}

/********************   ExprOrBase    ********************/

ExprOr make_ExprOrBase( Expr p1 )
{
   ExprOr tmp = ( ExprOr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ExprOrBase!\n" );
      exit( 1 );
   }
   tmp->kind                = is_ExprOrBase;
   tmp->u.exprOrBase_.expr_ = p1;
   return tmp;
}

/********************   CallExprMain    ********************/

CallExpr make_CallExprMain( QualifiedId p1, ArgListOpt p2 )
{
   CallExpr tmp = ( CallExpr ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating CallExprMain!\n" );
      exit( 1 );
   }
   tmp->kind                         = is_CallExprMain;
   tmp->u.callExprMain_.qualifiedid_ = p1;
   tmp->u.callExprMain_.arglistopt_  = p2;
   return tmp;
}

/********************   OptArgListEmpty    ********************/

ArgListOpt make_OptArgListEmpty()
{
   ArgListOpt tmp = ( ArgListOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptArgListEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptArgListEmpty;
   return tmp;
}

/********************   OptArgListSome    ********************/

ArgListOpt make_OptArgListSome( Expr p1, ArgListTail p2 )
{
   ArgListOpt tmp = ( ArgListOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptArgListSome!\n" );
      exit( 1 );
   }
   tmp->kind                           = is_OptArgListSome;
   tmp->u.optArgListSome_.expr_        = p1;
   tmp->u.optArgListSome_.arglisttail_ = p2;
   return tmp;
}

/********************   ListArgTailEmpty    ********************/

ArgListTail make_ListArgTailEmpty()
{
   ArgListTail tmp = ( ArgListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListArgTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListArgTailEmpty;
   return tmp;
}

/********************   ListArgTailCons    ********************/

ArgListTail make_ListArgTailCons( Expr p1, ArgListTail p2 )
{
   ArgListTail tmp = ( ArgListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListArgTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                            = is_ListArgTailCons;
   tmp->u.listArgTailCons_.expr_        = p1;
   tmp->u.listArgTailCons_.arglisttail_ = p2;
   return tmp;
}

/********************   OptExprListEmpty    ********************/

ExprListOpt make_OptExprListEmpty()
{
   ExprListOpt tmp = ( ExprListOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptExprListEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptExprListEmpty;
   return tmp;
}

/********************   OptExprListSome    ********************/

ExprListOpt make_OptExprListSome( Expr p1, ExprListTail p2 )
{
   ExprListOpt tmp = ( ExprListOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptExprListSome!\n" );
      exit( 1 );
   }
   tmp->kind                             = is_OptExprListSome;
   tmp->u.optExprListSome_.expr_         = p1;
   tmp->u.optExprListSome_.exprlisttail_ = p2;
   return tmp;
}

/********************   ListExprTailEmpty    ********************/

ExprListTail make_ListExprTailEmpty()
{
   ExprListTail tmp = ( ExprListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListExprTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListExprTailEmpty;
   return tmp;
}

/********************   ListExprTailCons    ********************/

ExprListTail make_ListExprTailCons( Expr p1, ExprListTail p2 )
{
   ExprListTail tmp = ( ExprListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListExprTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                              = is_ListExprTailCons;
   tmp->u.listExprTailCons_.expr_         = p1;
   tmp->u.listExprTailCons_.exprlisttail_ = p2;
   return tmp;
}

/********************   QualifiedIdSingle    ********************/

QualifiedId make_QualifiedIdSingle( Ident p1 )
{
   QualifiedId tmp = ( QualifiedId ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating QualifiedIdSingle!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_QualifiedIdSingle;
   tmp->u.qualifiedIdSingle_.ident_ = p1;
   return tmp;
}

/********************   QualifiedIdMore    ********************/

QualifiedId make_QualifiedIdMore( Ident p1, QualifiedId p2 )
{
   QualifiedId tmp = ( QualifiedId ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating QualifiedIdMore!\n" );
      exit( 1 );
   }
   tmp->kind                            = is_QualifiedIdMore;
   tmp->u.qualifiedIdMore_.ident_       = p1;
   tmp->u.qualifiedIdMore_.qualifiedid_ = p2;
   return tmp;
}

/********************   LHSVal    ********************/

LHS make_LHSVal( LValue p1 )
{
   LHS tmp = ( LHS ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LHSVal!\n" );
      exit( 1 );
   }
   tmp->kind              = is_LHSVal;
   tmp->u.lHSVal_.lvalue_ = p1;
   return tmp;
}

/********************   LHSDeref    ********************/

LHS make_LHSDeref( Expr p1 )
{
   LHS tmp = ( LHS ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LHSDeref!\n" );
      exit( 1 );
   }
   tmp->kind              = is_LHSDeref;
   tmp->u.lHSDeref_.expr_ = p1;
   return tmp;
}

/********************   LValQId    ********************/

LValue make_LValQId( QualifiedId p1 )
{
   LValue tmp = ( LValue ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LValQId!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_LValQId;
   tmp->u.lValQId_.qualifiedid_ = p1;
   return tmp;
}

/********************   LValField    ********************/

LValue make_LValField( LValue p1, Ident p2 )
{
   LValue tmp = ( LValue ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LValField!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_LValField;
   tmp->u.lValField_.lvalue_ = p1;
   tmp->u.lValField_.ident_  = p2;
   return tmp;
}

/********************   LValIndex    ********************/

LValue make_LValIndex( LValue p1, SubscriptList p2 )
{
   LValue tmp = ( LValue ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LValIndex!\n" );
      exit( 1 );
   }
   tmp->kind                        = is_LValIndex;
   tmp->u.lValIndex_.lvalue_        = p1;
   tmp->u.lValIndex_.subscriptlist_ = p2;
   return tmp;
}

/********************   SubscriptListSingle    ********************/

SubscriptList make_SubscriptListSingle( Expr p1, SubscriptListTail p2 )
{
   SubscriptList tmp = ( SubscriptList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating SubscriptListSingle!\n" );
      exit( 1 );
   }
   tmp->kind                                      = is_SubscriptListSingle;
   tmp->u.subscriptListSingle_.expr_              = p1;
   tmp->u.subscriptListSingle_.subscriptlisttail_ = p2;
   return tmp;
}

/********************   ListSubscriptTailEmpty    ********************/

SubscriptListTail make_ListSubscriptTailEmpty()
{
   SubscriptListTail tmp = ( SubscriptListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListSubscriptTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListSubscriptTailEmpty;
   return tmp;
}

/********************   ListSubscriptTailCons    ********************/

SubscriptListTail make_ListSubscriptTailCons( Expr p1, SubscriptListTail p2 )
{
   SubscriptListTail tmp = ( SubscriptListTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListSubscriptTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                                        = is_ListSubscriptTailCons;
   tmp->u.listSubscriptTailCons_.expr_              = p1;
   tmp->u.listSubscriptTailCons_.subscriptlisttail_ = p2;
   return tmp;
}

/********************   LitNil    ********************/

Literal make_LitNil()
{
   Literal tmp = ( Literal ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LitNil!\n" );
      exit( 1 );
   }
   tmp->kind = is_LitNil;
   return tmp;
}

/********************   LitTrueDot    ********************/

Literal make_LitTrueDot()
{
   Literal tmp = ( Literal ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LitTrueDot!\n" );
      exit( 1 );
   }
   tmp->kind = is_LitTrueDot;
   return tmp;
}

/********************   LitFalseDot    ********************/

Literal make_LitFalseDot()
{
   Literal tmp = ( Literal ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LitFalseDot!\n" );
      exit( 1 );
   }
   tmp->kind = is_LitFalseDot;
   return tmp;
}

/********************   LitInt    ********************/

Literal make_LitInt( IntLit p1 )
{
   Literal tmp = ( Literal ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LitInt!\n" );
      exit( 1 );
   }
   tmp->kind              = is_LitInt;
   tmp->u.litInt_.intlit_ = p1;
   return tmp;
}

/********************   LitFloat    ********************/

Literal make_LitFloat( FloatLit p1 )
{
   Literal tmp = ( Literal ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LitFloat!\n" );
      exit( 1 );
   }
   tmp->kind                  = is_LitFloat;
   tmp->u.litFloat_.floatlit_ = p1;
   return tmp;
}

/********************   LitStr    ********************/

Literal make_LitStr( Napis p1 )
{
   Literal tmp = ( Literal ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LitStr!\n" );
      exit( 1 );
   }
   tmp->kind             = is_LitStr;
   tmp->u.litStr_.napis_ = p1;
   return tmp;
}

/********************   NapisStr    ********************/

Napis make_NapisStr( StrLit p1 )
{
   Napis tmp = ( Napis ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating NapisStr!\n" );
      exit( 1 );
   }
   tmp->kind                = is_NapisStr;
   tmp->u.napisStr_.strlit_ = p1;
   return tmp;
}

/********************   DefFun    ********************/

Def make_DefFun( FunctionDef p1 )
{
   Def tmp = ( Def ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating DefFun!\n" );
      exit( 1 );
   }
   tmp->kind                   = is_DefFun;
   tmp->u.defFun_.functiondef_ = p1;
   return tmp;
}

/********************   DefProc    ********************/

Def make_DefProc( ProcedureDef p1 )
{
   Def tmp = ( Def ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating DefProc!\n" );
      exit( 1 );
   }
   tmp->kind                     = is_DefProc;
   tmp->u.defProc_.proceduredef_ = p1;
   return tmp;
}

/********************   DefMeth    ********************/

Def make_DefMeth( MethodDef p1 )
{
   Def tmp = ( Def ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating DefMeth!\n" );
      exit( 1 );
   }
   tmp->kind                  = is_DefMeth;
   tmp->u.defMeth_.methoddef_ = p1;
   return tmp;
}

/********************   FunctionDefMain    ********************/

FunctionDef make_FunctionDefMain( StaticOpt p1, Ident p2, ParamListOpt p3, LineEol p4, LocalDeclsOpt p5,
                                  StaticDeclsOpt p6, StmtListNonEmpty p7 )
{
   FunctionDef tmp = ( FunctionDef ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating FunctionDefMain!\n" );
      exit( 1 );
   }
   tmp->kind                                 = is_FunctionDefMain;
   tmp->u.functionDefMain_.staticopt_        = p1;
   tmp->u.functionDefMain_.ident_            = p2;
   tmp->u.functionDefMain_.paramlistopt_     = p3;
   tmp->u.functionDefMain_.lineeol_          = p4;
   tmp->u.functionDefMain_.localdeclsopt_    = p5;
   tmp->u.functionDefMain_.staticdeclsopt_   = p6;
   tmp->u.functionDefMain_.stmtlistnonempty_ = p7;
   return tmp;
}

/********************   ProcedureDefMain    ********************/

ProcedureDef make_ProcedureDefMain( StaticOpt p1, Ident p2, ParamListOpt p3, LineEol p4, LocalDeclsOpt p5,
                                    StaticDeclsOpt p6, StmtListNonEmpty p7 )
{
   ProcedureDef tmp = ( ProcedureDef ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ProcedureDefMain!\n" );
      exit( 1 );
   }
   tmp->kind                                  = is_ProcedureDefMain;
   tmp->u.procedureDefMain_.staticopt_        = p1;
   tmp->u.procedureDefMain_.ident_            = p2;
   tmp->u.procedureDefMain_.paramlistopt_     = p3;
   tmp->u.procedureDefMain_.lineeol_          = p4;
   tmp->u.procedureDefMain_.localdeclsopt_    = p5;
   tmp->u.procedureDefMain_.staticdeclsopt_   = p6;
   tmp->u.procedureDefMain_.stmtlistnonempty_ = p7;
   return tmp;
}

/********************   OptStaticEmpty    ********************/

StaticOpt make_OptStaticEmpty()
{
   StaticOpt tmp = ( StaticOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptStaticEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptStaticEmpty;
   return tmp;
}

/********************   OptStaticSome    ********************/

StaticOpt make_OptStaticSome()
{
   StaticOpt tmp = ( StaticOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptStaticSome!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptStaticSome;
   return tmp;
}

/********************   ListLocalDeclEmpty    ********************/

LocalDeclsOpt make_ListLocalDeclEmpty()
{
   LocalDeclsOpt tmp = ( LocalDeclsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListLocalDeclEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListLocalDeclEmpty;
   return tmp;
}

/********************   ListLocalDeclLine    ********************/

LocalDeclsOpt make_ListLocalDeclLine( LineEol p1, LocalDeclsOpt p2 )
{
   LocalDeclsOpt tmp = ( LocalDeclsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListLocalDeclLine!\n" );
      exit( 1 );
   }
   tmp->kind                                = is_ListLocalDeclLine;
   tmp->u.listLocalDeclLine_.lineeol_       = p1;
   tmp->u.listLocalDeclLine_.localdeclsopt_ = p2;
   return tmp;
}

/********************   ListLocalDeclCons    ********************/

LocalDeclsOpt make_ListLocalDeclCons( LocalDecl p1, LocalDeclsOpt p2 )
{
   LocalDeclsOpt tmp = ( LocalDeclsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListLocalDeclCons!\n" );
      exit( 1 );
   }
   tmp->kind                                = is_ListLocalDeclCons;
   tmp->u.listLocalDeclCons_.localdecl_     = p1;
   tmp->u.listLocalDeclCons_.localdeclsopt_ = p2;
   return tmp;
}

/********************   LocalDeclItem    ********************/

LocalDecl make_LocalDeclItem( IdentInitList p1, StmtEnd p2 )
{
   LocalDecl tmp = ( LocalDecl ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating LocalDeclItem!\n" );
      exit( 1 );
   }
   tmp->kind                            = is_LocalDeclItem;
   tmp->u.localDeclItem_.identinitlist_ = p1;
   tmp->u.localDeclItem_.stmtend_       = p2;
   return tmp;
}

/********************   ListStaticDeclEmpty    ********************/

StaticDeclsOpt make_ListStaticDeclEmpty()
{
   StaticDeclsOpt tmp = ( StaticDeclsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListStaticDeclEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListStaticDeclEmpty;
   return tmp;
}

/********************   ListStaticDeclCons    ********************/

StaticDeclsOpt make_ListStaticDeclCons( StaticDecl p1, StaticDeclsOpt p2 )
{
   StaticDeclsOpt tmp = ( StaticDeclsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListStaticDeclCons!\n" );
      exit( 1 );
   }
   tmp->kind                                  = is_ListStaticDeclCons;
   tmp->u.listStaticDeclCons_.staticdecl_     = p1;
   tmp->u.listStaticDeclCons_.staticdeclsopt_ = p2;
   return tmp;
}

/********************   StaticItemListSingle    ********************/

StaticItemList make_StaticItemListSingle( StaticItem p1, StaticItemTail p2 )
{
   StaticItemList tmp = ( StaticItemList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticItemListSingle!\n" );
      exit( 1 );
   }
   tmp->kind                                    = is_StaticItemListSingle;
   tmp->u.staticItemListSingle_.staticitem_     = p1;
   tmp->u.staticItemListSingle_.staticitemtail_ = p2;
   return tmp;
}

/********************   StaticItemTailEmpty    ********************/

StaticItemTail make_StaticItemTailEmpty()
{
   StaticItemTail tmp = ( StaticItemTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticItemTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_StaticItemTailEmpty;
   return tmp;
}

/********************   StaticItemTailCons    ********************/

StaticItemTail make_StaticItemTailCons( StaticItem p1, StaticItemTail p2 )
{
   StaticItemTail tmp = ( StaticItemTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticItemTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                                  = is_StaticItemTailCons;
   tmp->u.staticItemTailCons_.staticitem_     = p1;
   tmp->u.staticItemTailCons_.staticitemtail_ = p2;
   return tmp;
}

/********************   StaticItemMain    ********************/

StaticItem make_StaticItemMain( Ident p1, StaticArrayDimsOpt p2, StaticInitOpt p3 )
{
   StaticItem tmp = ( StaticItem ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticItemMain!\n" );
      exit( 1 );
   }
   tmp->kind                                  = is_StaticItemMain;
   tmp->u.staticItemMain_.ident_              = p1;
   tmp->u.staticItemMain_.staticarraydimsopt_ = p2;
   tmp->u.staticItemMain_.staticinitopt_      = p3;
   return tmp;
}

/********************   StaticArrayDimsEmpty    ********************/

StaticArrayDimsOpt make_StaticArrayDimsEmpty()
{
   StaticArrayDimsOpt tmp = ( StaticArrayDimsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticArrayDimsEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_StaticArrayDimsEmpty;
   return tmp;
}

/********************   StaticArrayDimsCons    ********************/

StaticArrayDimsOpt make_StaticArrayDimsCons( SubscriptList p1, StaticArrayDimsOpt p2 )
{
   StaticArrayDimsOpt tmp = ( StaticArrayDimsOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticArrayDimsCons!\n" );
      exit( 1 );
   }
   tmp->kind                                       = is_StaticArrayDimsCons;
   tmp->u.staticArrayDimsCons_.subscriptlist_      = p1;
   tmp->u.staticArrayDimsCons_.staticarraydimsopt_ = p2;
   return tmp;
}

/********************   StaticInitEmpty    ********************/

StaticInitOpt make_StaticInitEmpty()
{
   StaticInitOpt tmp = ( StaticInitOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticInitEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_StaticInitEmpty;
   return tmp;
}

/********************   StaticInitSome    ********************/

StaticInitOpt make_StaticInitSome( Expr p1 )
{
   StaticInitOpt tmp = ( StaticInitOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating StaticInitSome!\n" );
      exit( 1 );
   }
   tmp->kind                    = is_StaticInitSome;
   tmp->u.staticInitSome_.expr_ = p1;
   return tmp;
}

/********************   ListIdentInitSingle    ********************/

IdentInitList make_ListIdentInitSingle( IdentInit p1, IdentInitTail p2 )
{
   IdentInitList tmp = ( IdentInitList ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListIdentInitSingle!\n" );
      exit( 1 );
   }
   tmp->kind                                  = is_ListIdentInitSingle;
   tmp->u.listIdentInitSingle_.identinit_     = p1;
   tmp->u.listIdentInitSingle_.identinittail_ = p2;
   return tmp;
}

/********************   ListIdentInitTailEmpty    ********************/

IdentInitTail make_ListIdentInitTailEmpty()
{
   IdentInitTail tmp = ( IdentInitTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListIdentInitTailEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_ListIdentInitTailEmpty;
   return tmp;
}

/********************   ListIdentInitTailCons    ********************/

IdentInitTail make_ListIdentInitTailCons( IdentInit p1, IdentInitTail p2 )
{
   IdentInitTail tmp = ( IdentInitTail ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating ListIdentInitTailCons!\n" );
      exit( 1 );
   }
   tmp->kind                                    = is_ListIdentInitTailCons;
   tmp->u.listIdentInitTailCons_.identinit_     = p1;
   tmp->u.listIdentInitTailCons_.identinittail_ = p2;
   return tmp;
}

/********************   IdentInitItem    ********************/

IdentInit make_IdentInitItem( Ident p1, InitOpt p2 )
{
   IdentInit tmp = ( IdentInit ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating IdentInitItem!\n" );
      exit( 1 );
   }
   tmp->kind                      = is_IdentInitItem;
   tmp->u.identInitItem_.ident_   = p1;
   tmp->u.identInitItem_.initopt_ = p2;
   return tmp;
}

/********************   OptInitEmpty    ********************/

InitOpt make_OptInitEmpty()
{
   InitOpt tmp = ( InitOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptInitEmpty!\n" );
      exit( 1 );
   }
   tmp->kind = is_OptInitEmpty;
   return tmp;
}

/********************   OptInitSome    ********************/

InitOpt make_OptInitSome( Expr p1 )
{
   InitOpt tmp = ( InitOpt ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating OptInitSome!\n" );
      exit( 1 );
   }
   tmp->kind                 = is_OptInitSome;
   tmp->u.optInitSome_.expr_ = p1;
   return tmp;
}

/********************   MethodDefMain    ********************/

MethodDef make_MethodDefMain( StaticOpt p1, Ident p2, ParamListOpt p3, ClassName p4, LineEol p5, LocalDeclsOpt p6,
                              StaticDeclsOpt p7, StmtListNonEmpty p8 )
{
   MethodDef tmp = ( MethodDef ) malloc( sizeof( *tmp ) );
   if( !tmp )
   {
      fprintf( stderr, "Error: out of memory when allocating MethodDefMain!\n" );
      exit( 1 );
   }
   tmp->kind                               = is_MethodDefMain;
   tmp->u.methodDefMain_.staticopt_        = p1;
   tmp->u.methodDefMain_.ident_            = p2;
   tmp->u.methodDefMain_.paramlistopt_     = p3;
   tmp->u.methodDefMain_.classname_        = p4;
   tmp->u.methodDefMain_.lineeol_          = p5;
   tmp->u.methodDefMain_.localdeclsopt_    = p6;
   tmp->u.methodDefMain_.staticdeclsopt_   = p7;
   tmp->u.methodDefMain_.stmtlistnonempty_ = p8;
   return tmp;
}

/***************************   Cloning   ******************************/

Program clone_Program( Program p )
{
   switch( p->kind )
   {
   case is_ProgramRoot:
      return make_ProgramRoot( clone_LeadingEols( p->u.programRoot_.leadingeols_ ),
                               clone_TopDecls( p->u.programRoot_.topdecls_ ), clone_Defs( p->u.programRoot_.defs_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning Program!\n" );
      exit( 1 );
   }
}

LeadingEols clone_LeadingEols( LeadingEols p )
{
   switch( p->kind )
   {
   case is_LeadingEolsEmpty:
      return make_LeadingEolsEmpty();

   default:
      fprintf( stderr, "Error: bad kind field when cloning LeadingEols!\n" );
      exit( 1 );
   }
}

TopDecls clone_TopDecls( TopDecls p )
{
   switch( p->kind )
   {
   case is_ListTopDeclEmpty:
      return make_ListTopDeclEmpty();

   case is_ListTopDeclCons:
      return make_ListTopDeclCons( clone_TopDecl( p->u.listTopDeclCons_.topdecl_ ),
                                   clone_TopDecls( p->u.listTopDeclCons_.topdecls_ ) );

   case is_ListTopDeclLine:
      return make_ListTopDeclLine( strdup( p->u.listTopDeclLine_.lineeol_ ),
                                   clone_TopDecls( p->u.listTopDeclLine_.topdecls_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning TopDecls!\n" );
      exit( 1 );
   }
}

TopDecl clone_TopDecl( TopDecl p )
{
   switch( p->kind )
   {
   case is_TopDeclEnum:
      return make_TopDeclEnum( clone_EnumDecl( p->u.topDeclEnum_.enumdecl_ ) );

   case is_TopDeclClass:
      return make_TopDeclClass( clone_ClassDecl( p->u.topDeclClass_.classdecl_ ) );

   case is_TopDeclStruct:
      return make_TopDeclStruct( clone_StructDecl( p->u.topDeclStruct_.structdecl_ ) );

   case is_TopDeclPreproc:
      return make_TopDeclPreproc( clone_PreprocDecl( p->u.topDeclPreproc_.preprocdecl_ ) );

   case is_TopDeclStatic:
      return make_TopDeclStatic( clone_StaticDecl( p->u.topDeclStatic_.staticdecl_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning TopDecl!\n" );
      exit( 1 );
   }
}

Defs clone_Defs( Defs p )
{
   switch( p->kind )
   {
   case is_ListDefSingle:
      return make_ListDefSingle( clone_Def( p->u.listDefSingle_.def_ ) );

   case is_ListDefCons:
      return make_ListDefCons( clone_Def( p->u.listDefCons_.def_ ), clone_Defs( p->u.listDefCons_.defs_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning Defs!\n" );
      exit( 1 );
   }
}

PreprocDecl clone_PreprocDecl( PreprocDecl p )
{
   switch( p->kind )
   {
   case is_PreprocDeclLine:
      return make_PreprocDeclLine( strdup( p->u.preprocDeclLine_.preprocline_ ),
                                   clone_StmtEnd( p->u.preprocDeclLine_.stmtend_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning PreprocDecl!\n" );
      exit( 1 );
   }
}

ParamListOpt clone_ParamListOpt( ParamListOpt p )
{
   switch( p->kind )
   {
   case is_OptParamListEmpty:
      return make_OptParamListEmpty();

   case is_OptParamListSome:
      return make_OptParamListSome( strdup( p->u.optParamListSome_.ident_ ),
                                    clone_ParamListTail( p->u.optParamListSome_.paramlisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ParamListOpt!\n" );
      exit( 1 );
   }
}

ParamListTail clone_ParamListTail( ParamListTail p )
{
   switch( p->kind )
   {
   case is_ListParamTailEmpty:
      return make_ListParamTailEmpty();

   case is_ListParamTailCons:
      return make_ListParamTailCons( strdup( p->u.listParamTailCons_.ident_ ),
                                     clone_ParamListTail( p->u.listParamTailCons_.paramlisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ParamListTail!\n" );
      exit( 1 );
   }
}

Stmt clone_Stmt( Stmt p )
{
   switch( p->kind )
   {
   case is_StmtAssignInl:
      return make_StmtAssignInl( clone_LHS( p->u.stmtAssignInl_.lhs_ ), clone_Expr( p->u.stmtAssignInl_.expr_ ),
                                 clone_StmtEnd( p->u.stmtAssignInl_.stmtend_ ) );

   case is_StmtAssignAdd:
      return make_StmtAssignAdd( clone_LHS( p->u.stmtAssignAdd_.lhs_ ), clone_Expr( p->u.stmtAssignAdd_.expr_ ),
                                 clone_StmtEnd( p->u.stmtAssignAdd_.stmtend_ ) );

   case is_StmtAssignSub:
      return make_StmtAssignSub( clone_LHS( p->u.stmtAssignSub_.lhs_ ), clone_Expr( p->u.stmtAssignSub_.expr_ ),
                                 clone_StmtEnd( p->u.stmtAssignSub_.stmtend_ ) );

   case is_StmtAssignMul:
      return make_StmtAssignMul( clone_LHS( p->u.stmtAssignMul_.lhs_ ), clone_Expr( p->u.stmtAssignMul_.expr_ ),
                                 clone_StmtEnd( p->u.stmtAssignMul_.stmtend_ ) );

   case is_StmtAssignDiv:
      return make_StmtAssignDiv( clone_LHS( p->u.stmtAssignDiv_.lhs_ ), clone_Expr( p->u.stmtAssignDiv_.expr_ ),
                                 clone_StmtEnd( p->u.stmtAssignDiv_.stmtend_ ) );

   case is_StmtAssignMod:
      return make_StmtAssignMod( clone_LHS( p->u.stmtAssignMod_.lhs_ ), clone_Expr( p->u.stmtAssignMod_.expr_ ),
                                 clone_StmtEnd( p->u.stmtAssignMod_.stmtend_ ) );

   case is_StmtAssignPow:
      return make_StmtAssignPow( clone_LHS( p->u.stmtAssignPow_.lhs_ ), clone_Expr( p->u.stmtAssignPow_.expr_ ),
                                 clone_StmtEnd( p->u.stmtAssignPow_.stmtend_ ) );

   case is_StmtAssignPow2:
      return make_StmtAssignPow2( clone_LHS( p->u.stmtAssignPow2_.lhs_ ), clone_Expr( p->u.stmtAssignPow2_.expr_ ),
                                  clone_StmtEnd( p->u.stmtAssignPow2_.stmtend_ ) );

   case is_StmtCall:
      return make_StmtCall( clone_CallExpr( p->u.stmtCall_.callexpr_ ), clone_StmtEnd( p->u.stmtCall_.stmtend_ ) );

   case is_StmtIf:
      return make_StmtIf( clone_IfCond( p->u.stmtIf_.ifcond_ ), strdup( p->u.stmtIf_.lineeol_ ),
                          clone_StmtList( p->u.stmtIf_.stmtlist_ ), clone_ElseIfList( p->u.stmtIf_.elseiflist_ ),
                          clone_ElseOpt( p->u.stmtIf_.elseopt_ ), clone_EndIf( p->u.stmtIf_.endif_ ),
                          clone_StmtEnd( p->u.stmtIf_.stmtend_ ) );

   case is_StmtDoWhile:
      return make_StmtDoWhile( clone_DoOpt( p->u.stmtDoWhile_.doopt_ ), clone_WhileCond( p->u.stmtDoWhile_.whilecond_ ),
                               strdup( p->u.stmtDoWhile_.lineeol_ ), clone_StmtList( p->u.stmtDoWhile_.stmtlist_ ),
                               clone_EndDo( p->u.stmtDoWhile_.enddo_ ), clone_StmtEnd( p->u.stmtDoWhile_.stmtend_ ) );

   case is_StmtFor:
      return make_StmtFor( strdup( p->u.stmtFor_.ident_ ), clone_Expr( p->u.stmtFor_.expr_1 ),
                           clone_Expr( p->u.stmtFor_.expr_2 ), clone_StepOpt( p->u.stmtFor_.stepopt_ ),
                           strdup( p->u.stmtFor_.lineeol_ ), clone_StmtList( p->u.stmtFor_.stmtlist_ ),
                           clone_EndFor( p->u.stmtFor_.endfor_ ), clone_StmtEnd( p->u.stmtFor_.stmtend_ ) );

   case is_StmtForEach:
      return make_StmtForEach( clone_ForEachVars( p->u.stmtForEach_.foreachvars_ ),
                               clone_ForEachExprs( p->u.stmtForEach_.foreachexprs_ ),
                               clone_ForEachDescOpt( p->u.stmtForEach_.foreachdescopt_ ),
                               strdup( p->u.stmtForEach_.lineeol_ ), clone_StmtList( p->u.stmtForEach_.stmtlist_ ),
                               clone_EndFor( p->u.stmtForEach_.endfor_ ), clone_StmtEnd( p->u.stmtForEach_.stmtend_ ) );

   case is_StmtSwitch:
      return make_StmtSwitch(
          clone_SwitchCond( p->u.stmtSwitch_.switchcond_ ), strdup( p->u.stmtSwitch_.lineeol_ ),
          clone_CaseList( p->u.stmtSwitch_.caselist_ ), clone_OtherwiseOpt( p->u.stmtSwitch_.otherwiseopt_ ),
          clone_EndSwitch( p->u.stmtSwitch_.endswitch_ ), clone_StmtEnd( p->u.stmtSwitch_.stmtend_ ) );

   case is_StmtDoCase:
      return make_StmtDoCase( strdup( p->u.stmtDoCase_.lineeol_ ), clone_CaseCondList( p->u.stmtDoCase_.casecondlist_ ),
                              clone_OtherwiseOpt( p->u.stmtDoCase_.otherwiseopt_ ),
                              clone_EndCase( p->u.stmtDoCase_.endcase_ ), clone_StmtEnd( p->u.stmtDoCase_.stmtend_ ) );

   case is_StmtSequence:
      return make_StmtSequence( strdup( p->u.stmtSequence_.lineeol_ ), clone_StmtList( p->u.stmtSequence_.stmtlist_ ),
                                clone_RecoverOpt( p->u.stmtSequence_.recoveropt_ ),
                                clone_EndSequence( p->u.stmtSequence_.endsequence_ ),
                                clone_StmtEnd( p->u.stmtSequence_.stmtend_ ) );

   case is_StmtBreak:
      return make_StmtBreak( clone_BreakExprOpt( p->u.stmtBreak_.breakexpropt_ ),
                             clone_StmtEnd( p->u.stmtBreak_.stmtend_ ) );

   case is_StmtExit:
      return make_StmtExit( clone_StmtEnd( p->u.stmtExit_.stmtend_ ) );

   case is_StmtLoop:
      return make_StmtLoop( clone_StmtEnd( p->u.stmtLoop_.stmtend_ ) );

   case is_StmtReturn:
      return make_StmtReturn( clone_ReturnExprOpt( p->u.stmtReturn_.returnexpropt_ ),
                              clone_StmtEnd( p->u.stmtReturn_.stmtend_ ) );

   case is_StmtStructDecl:
      return make_StmtStructDecl( clone_StructDecl( p->u.stmtStructDecl_.structdecl_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning Stmt!\n" );
      exit( 1 );
   }
}

ReturnExprOpt clone_ReturnExprOpt( ReturnExprOpt p )
{
   switch( p->kind )
   {
   case is_ReturnExprOptEmpty:
      return make_ReturnExprOptEmpty();

   case is_ReturnExprOptSome:
      return make_ReturnExprOptSome( clone_Expr( p->u.returnExprOptSome_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ReturnExprOpt!\n" );
      exit( 1 );
   }
}

StmtList clone_StmtList( StmtList p )
{
   switch( p->kind )
   {
   case is_ListStmtEmpty:
      return make_ListStmtEmpty();

   case is_ListStmtCons:
      return make_ListStmtCons( clone_Stmt( p->u.listStmtCons_.stmt_ ),
                                clone_StmtList( p->u.listStmtCons_.stmtlist_ ) );

   case is_ListStmtLine:
      return make_ListStmtLine( strdup( p->u.listStmtLine_.lineeol_ ), clone_StmtList( p->u.listStmtLine_.stmtlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StmtList!\n" );
      exit( 1 );
   }
}

StmtListNonEmpty clone_StmtListNonEmpty( StmtListNonEmpty p )
{
   switch( p->kind )
   {
   case is_ListStmtNonEmpty:
      return make_ListStmtNonEmpty( clone_Stmt( p->u.listStmtNonEmpty_.stmt_ ),
                                    clone_StmtList( p->u.listStmtNonEmpty_.stmtlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StmtListNonEmpty!\n" );
      exit( 1 );
   }
}

ElseIfList clone_ElseIfList( ElseIfList p )
{
   switch( p->kind )
   {
   case is_ListElseIfEmpty:
      return make_ListElseIfEmpty();

   case is_ListElseIfCons:
      return make_ListElseIfCons( clone_ElseIf( p->u.listElseIfCons_.elseif_ ),
                                  clone_ElseIfList( p->u.listElseIfCons_.elseiflist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ElseIfList!\n" );
      exit( 1 );
   }
}

ElseIf clone_ElseIf( ElseIf p )
{
   switch( p->kind )
   {
   case is_ElseIfClause:
      return make_ElseIfClause( clone_IfCond( p->u.elseIfClause_.ifcond_ ), strdup( p->u.elseIfClause_.lineeol_ ),
                                clone_StmtList( p->u.elseIfClause_.stmtlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ElseIf!\n" );
      exit( 1 );
   }
}

ElseOpt clone_ElseOpt( ElseOpt p )
{
   switch( p->kind )
   {
   case is_OptElseEmpty:
      return make_OptElseEmpty();

   case is_OptElseSome:
      return make_OptElseSome( strdup( p->u.optElseSome_.lineeol_ ), clone_StmtList( p->u.optElseSome_.stmtlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ElseOpt!\n" );
      exit( 1 );
   }
}

IfCond clone_IfCond( IfCond p )
{
   switch( p->kind )
   {
   case is_IfCondExpr:
      return make_IfCondExpr( clone_Expr( p->u.ifCondExpr_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning IfCond!\n" );
      exit( 1 );
   }
}

EndIf clone_EndIf( EndIf p )
{
   switch( p->kind )
   {
   case is_EndIfWord:
      return make_EndIfWord();

   case is_EndIfClause:
      return make_EndIfClause( clone_EndIfOpt( p->u.endIfClause_.endifopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndIf!\n" );
      exit( 1 );
   }
}

EndIfOpt clone_EndIfOpt( EndIfOpt p )
{
   switch( p->kind )
   {
   case is_EndIfOptEmpty:
      return make_EndIfOptEmpty();

   case is_EndIfOptIf:
      return make_EndIfOptIf();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndIfOpt!\n" );
      exit( 1 );
   }
}

DoOpt clone_DoOpt( DoOpt p )
{
   switch( p->kind )
   {
   case is_DoOptEmpty:
      return make_DoOptEmpty();

   case is_DoOptDo:
      return make_DoOptDo();

   default:
      fprintf( stderr, "Error: bad kind field when cloning DoOpt!\n" );
      exit( 1 );
   }
}

WhileCond clone_WhileCond( WhileCond p )
{
   switch( p->kind )
   {
   case is_WhileCondExpr:
      return make_WhileCondExpr( clone_Expr( p->u.whileCondExpr_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning WhileCond!\n" );
      exit( 1 );
   }
}

EndDo clone_EndDo( EndDo p )
{
   switch( p->kind )
   {
   case is_EndDoWord:
      return make_EndDoWord();

   case is_EndWhileWord:
      return make_EndWhileWord();

   case is_EndDoClause:
      return make_EndDoClause( clone_EndDoOpt( p->u.endDoClause_.enddoopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndDo!\n" );
      exit( 1 );
   }
}

EndDoOpt clone_EndDoOpt( EndDoOpt p )
{
   switch( p->kind )
   {
   case is_EndDoOptEmpty:
      return make_EndDoOptEmpty();

   case is_EndDoOptDo:
      return make_EndDoOptDo();

   case is_EndDoOptWhile:
      return make_EndDoOptWhile();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndDoOpt!\n" );
      exit( 1 );
   }
}

EndCase clone_EndCase( EndCase p )
{
   switch( p->kind )
   {
   case is_EndCaseWord:
      return make_EndCaseWord();

   case is_EndCaseClause:
      return make_EndCaseClause( clone_EndCaseOpt( p->u.endCaseClause_.endcaseopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndCase!\n" );
      exit( 1 );
   }
}

EndCaseOpt clone_EndCaseOpt( EndCaseOpt p )
{
   switch( p->kind )
   {
   case is_EndCaseOptEmpty:
      return make_EndCaseOptEmpty();

   case is_EndCaseOptCase:
      return make_EndCaseOptCase();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndCaseOpt!\n" );
      exit( 1 );
   }
}

StepOpt clone_StepOpt( StepOpt p )
{
   switch( p->kind )
   {
   case is_OptStepEmpty:
      return make_OptStepEmpty();

   case is_OptStepSome:
      return make_OptStepSome( clone_Expr( p->u.optStepSome_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StepOpt!\n" );
      exit( 1 );
   }
}

EndFor clone_EndFor( EndFor p )
{
   switch( p->kind )
   {
   case is_EndForWord:
      return make_EndForWord();

   case is_EndForClause:
      return make_EndForClause( clone_EndForOpt( p->u.endForClause_.endforopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndFor!\n" );
      exit( 1 );
   }
}

EndForOpt clone_EndForOpt( EndForOpt p )
{
   switch( p->kind )
   {
   case is_EndForOptEmpty:
      return make_EndForOptEmpty();

   case is_EndForOptFor:
      return make_EndForOptFor();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndForOpt!\n" );
      exit( 1 );
   }
}

ForEachVars clone_ForEachVars( ForEachVars p )
{
   switch( p->kind )
   {
   case is_ForEachVarsMain:
      return make_ForEachVarsMain( strdup( p->u.forEachVarsMain_.ident_ ),
                                   clone_ForEachVarsTail( p->u.forEachVarsMain_.foreachvarstail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ForEachVars!\n" );
      exit( 1 );
   }
}

ForEachVarsTail clone_ForEachVarsTail( ForEachVarsTail p )
{
   switch( p->kind )
   {
   case is_ListForEachVarsTailEmpty:
      return make_ListForEachVarsTailEmpty();

   case is_ListForEachVarsTailCons:
      return make_ListForEachVarsTailCons( strdup( p->u.listForEachVarsTailCons_.ident_ ),
                                           clone_ForEachVarsTail( p->u.listForEachVarsTailCons_.foreachvarstail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ForEachVarsTail!\n" );
      exit( 1 );
   }
}

ForEachExprs clone_ForEachExprs( ForEachExprs p )
{
   switch( p->kind )
   {
   case is_ForEachExprsMain:
      return make_ForEachExprsMain( clone_Expr( p->u.forEachExprsMain_.expr_ ),
                                    clone_ForEachExprsTail( p->u.forEachExprsMain_.foreachexprstail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ForEachExprs!\n" );
      exit( 1 );
   }
}

ForEachExprsTail clone_ForEachExprsTail( ForEachExprsTail p )
{
   switch( p->kind )
   {
   case is_ListForEachExprsTailEmpty:
      return make_ListForEachExprsTailEmpty();

   case is_ListForEachExprsTailCons:
      return make_ListForEachExprsTailCons(
          clone_Expr( p->u.listForEachExprsTailCons_.expr_ ),
          clone_ForEachExprsTail( p->u.listForEachExprsTailCons_.foreachexprstail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ForEachExprsTail!\n" );
      exit( 1 );
   }
}

ForEachDescOpt clone_ForEachDescOpt( ForEachDescOpt p )
{
   switch( p->kind )
   {
   case is_ForEachDescOptEmpty:
      return make_ForEachDescOptEmpty();

   case is_ForEachDescOptSome:
      return make_ForEachDescOptSome();

   default:
      fprintf( stderr, "Error: bad kind field when cloning ForEachDescOpt!\n" );
      exit( 1 );
   }
}

CaseList clone_CaseList( CaseList p )
{
   switch( p->kind )
   {
   case is_ListCaseEmpty:
      return make_ListCaseEmpty();

   case is_ListCaseCons:
      return make_ListCaseCons( clone_CaseClause( p->u.listCaseCons_.caseclause_ ),
                                clone_CaseList( p->u.listCaseCons_.caselist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning CaseList!\n" );
      exit( 1 );
   }
}

CaseClause clone_CaseClause( CaseClause p )
{
   switch( p->kind )
   {
   case is_CaseClauseItem:
      return make_CaseClauseItem( clone_CaseValue( p->u.caseClauseItem_.casevalue_ ),
                                  strdup( p->u.caseClauseItem_.lineeol_ ),
                                  clone_StmtList( p->u.caseClauseItem_.stmtlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning CaseClause!\n" );
      exit( 1 );
   }
}

CaseCondList clone_CaseCondList( CaseCondList p )
{
   switch( p->kind )
   {
   case is_ListCaseCondEmpty:
      return make_ListCaseCondEmpty();

   case is_ListCaseCondCons:
      return make_ListCaseCondCons( clone_CaseCondClause( p->u.listCaseCondCons_.casecondclause_ ),
                                    clone_CaseCondList( p->u.listCaseCondCons_.casecondlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning CaseCondList!\n" );
      exit( 1 );
   }
}

CaseCondClause clone_CaseCondClause( CaseCondClause p )
{
   switch( p->kind )
   {
   case is_CaseCondClauseItem:
      return make_CaseCondClauseItem( clone_Expr( p->u.caseCondClauseItem_.expr_ ),
                                      strdup( p->u.caseCondClauseItem_.lineeol_ ),
                                      clone_StmtList( p->u.caseCondClauseItem_.stmtlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning CaseCondClause!\n" );
      exit( 1 );
   }
}

OtherwiseOpt clone_OtherwiseOpt( OtherwiseOpt p )
{
   switch( p->kind )
   {
   case is_OptOtherwiseEmpty:
      return make_OptOtherwiseEmpty();

   case is_OptOtherwiseSome:
      return make_OptOtherwiseSome( strdup( p->u.optOtherwiseSome_.lineeol_ ),
                                    clone_StmtList( p->u.optOtherwiseSome_.stmtlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning OtherwiseOpt!\n" );
      exit( 1 );
   }
}

BreakExprOpt clone_BreakExprOpt( BreakExprOpt p )
{
   switch( p->kind )
   {
   case is_BreakExprOptEmpty:
      return make_BreakExprOptEmpty();

   case is_BreakExprOptSome:
      return make_BreakExprOptSome( clone_Expr( p->u.breakExprOptSome_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning BreakExprOpt!\n" );
      exit( 1 );
   }
}

RecoverOpt clone_RecoverOpt( RecoverOpt p )
{
   switch( p->kind )
   {
   case is_RecoverOptEmpty:
      return make_RecoverOptEmpty();

   case is_RecoverOptSome:
      return make_RecoverOptSome( clone_RecoverUsingOpt( p->u.recoverOptSome_.recoverusingopt_ ),
                                  strdup( p->u.recoverOptSome_.lineeol_ ),
                                  clone_StmtList( p->u.recoverOptSome_.stmtlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning RecoverOpt!\n" );
      exit( 1 );
   }
}

RecoverUsingOpt clone_RecoverUsingOpt( RecoverUsingOpt p )
{
   switch( p->kind )
   {
   case is_RecoverUsingOptEmpty:
      return make_RecoverUsingOptEmpty();

   case is_RecoverUsingOptSome:
      return make_RecoverUsingOptSome( strdup( p->u.recoverUsingOptSome_.ident_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning RecoverUsingOpt!\n" );
      exit( 1 );
   }
}

EndSequence clone_EndSequence( EndSequence p )
{
   switch( p->kind )
   {
   case is_EndSequenceWord:
      return make_EndSequenceWord();

   case is_EndSequenceClause:
      return make_EndSequenceClause( clone_EndSequenceOpt( p->u.endSequenceClause_.endsequenceopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndSequence!\n" );
      exit( 1 );
   }
}

EndSequenceOpt clone_EndSequenceOpt( EndSequenceOpt p )
{
   switch( p->kind )
   {
   case is_EndSequenceOptEmpty:
      return make_EndSequenceOptEmpty();

   case is_EndSequenceOptSeq:
      return make_EndSequenceOptSeq();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndSequenceOpt!\n" );
      exit( 1 );
   }
}

SwitchCond clone_SwitchCond( SwitchCond p )
{
   switch( p->kind )
   {
   case is_SwitchCondExpr:
      return make_SwitchCondExpr( clone_Expr( p->u.switchCondExpr_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning SwitchCond!\n" );
      exit( 1 );
   }
}

EndSwitch clone_EndSwitch( EndSwitch p )
{
   switch( p->kind )
   {
   case is_EndSwitchWord:
      return make_EndSwitchWord();

   case is_EndSwitchClause:
      return make_EndSwitchClause( clone_EndSwitchOpt( p->u.endSwitchClause_.endswitchopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndSwitch!\n" );
      exit( 1 );
   }
}

EndSwitchOpt clone_EndSwitchOpt( EndSwitchOpt p )
{
   switch( p->kind )
   {
   case is_EndSwitchOptEmpty:
      return make_EndSwitchOptEmpty();

   case is_EndSwitchOptSwitch:
      return make_EndSwitchOptSwitch();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndSwitchOpt!\n" );
      exit( 1 );
   }
}

EndStruct clone_EndStruct( EndStruct p )
{
   switch( p->kind )
   {
   case is_EndStructWord:
      return make_EndStructWord();

   case is_EndStructClause:
      return make_EndStructClause( clone_EndStructOpt( p->u.endStructClause_.endstructopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndStruct!\n" );
      exit( 1 );
   }
}

EndStructOpt clone_EndStructOpt( EndStructOpt p )
{
   switch( p->kind )
   {
   case is_EndStructOptEmpty:
      return make_EndStructOptEmpty();

   case is_EndStructOptStruct:
      return make_EndStructOptStruct();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndStructOpt!\n" );
      exit( 1 );
   }
}

EndClass clone_EndClass( EndClass p )
{
   switch( p->kind )
   {
   case is_EndClassWord:
      return make_EndClassWord();

   case is_EndClassClause:
      return make_EndClassClause( clone_EndClassOpt( p->u.endClassClause_.endclassopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndClass!\n" );
      exit( 1 );
   }
}

EndClassOpt clone_EndClassOpt( EndClassOpt p )
{
   switch( p->kind )
   {
   case is_EndClassOptEmpty:
      return make_EndClassOptEmpty();

   case is_EndClassOptClass:
      return make_EndClassOptClass();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndClassOpt!\n" );
      exit( 1 );
   }
}

EndEnum clone_EndEnum( EndEnum p )
{
   switch( p->kind )
   {
   case is_EndEnumWord:
      return make_EndEnumWord();

   case is_EndEnumClause:
      return make_EndEnumClause( clone_EndEnumOpt( p->u.endEnumClause_.endenumopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndEnum!\n" );
      exit( 1 );
   }
}

EndEnumOpt clone_EndEnumOpt( EndEnumOpt p )
{
   switch( p->kind )
   {
   case is_EndEnumOptEmpty:
      return make_EndEnumOptEmpty();

   case is_EndEnumOptEnum:
      return make_EndEnumOptEnum();

   default:
      fprintf( stderr, "Error: bad kind field when cloning EndEnumOpt!\n" );
      exit( 1 );
   }
}

CaseValue clone_CaseValue( CaseValue p )
{
   switch( p->kind )
   {
   case is_CaseValueInt:
      return make_CaseValueInt( strdup( p->u.caseValueInt_.intlit_ ) );

   case is_CaseValueStr:
      return make_CaseValueStr( clone_Napis( p->u.caseValueStr_.napis_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning CaseValue!\n" );
      exit( 1 );
   }
}

StmtEnd clone_StmtEnd( StmtEnd p )
{
   switch( p->kind )
   {
   case is_StmtEndLine:
      return make_StmtEndLine( strdup( p->u.stmtEndLine_.lineeol_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StmtEnd!\n" );
      exit( 1 );
   }
}

EnumDecl clone_EnumDecl( EnumDecl p )
{
   switch( p->kind )
   {
   case is_EnumDeclNamed:
      return make_EnumDeclNamed( strdup( p->u.enumDeclNamed_.ident_ ), strdup( p->u.enumDeclNamed_.lineeol_ ),
                                 clone_EnumListOpt( p->u.enumDeclNamed_.enumlistopt_ ),
                                 clone_EndEnum( p->u.enumDeclNamed_.endenum_ ),
                                 clone_StmtEnd( p->u.enumDeclNamed_.stmtend_ ) );

   case is_EnumDeclAnon:
      return make_EnumDeclAnon(
          strdup( p->u.enumDeclAnon_.lineeol_ ), clone_EnumListOpt( p->u.enumDeclAnon_.enumlistopt_ ),
          clone_EndEnum( p->u.enumDeclAnon_.endenum_ ), clone_StmtEnd( p->u.enumDeclAnon_.stmtend_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EnumDecl!\n" );
      exit( 1 );
   }
}

EnumListOpt clone_EnumListOpt( EnumListOpt p )
{
   switch( p->kind )
   {
   case is_OptEnumListEmpty:
      return make_OptEnumListEmpty();

   case is_OptEnumListSome:
      return make_OptEnumListSome( clone_EnumItem( p->u.optEnumListSome_.enumitem_ ),
                                   clone_EnumListTail( p->u.optEnumListSome_.enumlisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EnumListOpt!\n" );
      exit( 1 );
   }
}

EnumListTail clone_EnumListTail( EnumListTail p )
{
   switch( p->kind )
   {
   case is_ListEnumTailEmpty:
      return make_ListEnumTailEmpty();

   case is_ListEnumTailCons:
      return make_ListEnumTailCons( clone_EnumSep( p->u.listEnumTailCons_.enumsep_ ),
                                    clone_EnumItem( p->u.listEnumTailCons_.enumitem_ ),
                                    clone_EnumListTail( p->u.listEnumTailCons_.enumlisttail_ ) );

   case is_ListEnumTailSep:
      return make_ListEnumTailSep( clone_EnumSep( p->u.listEnumTailSep_.enumsep_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EnumListTail!\n" );
      exit( 1 );
   }
}

EnumSep clone_EnumSep( EnumSep p )
{
   switch( p->kind )
   {
   case is_EnumSepComma:
      return make_EnumSepComma( clone_LineEolOpt( p->u.enumSepComma_.lineeolopt_ ) );

   case is_EnumSepLine:
      return make_EnumSepLine( strdup( p->u.enumSepLine_.lineeol_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EnumSep!\n" );
      exit( 1 );
   }
}

EnumItem clone_EnumItem( EnumItem p )
{
   switch( p->kind )
   {
   case is_EnumItemDecl:
      return make_EnumItemDecl( strdup( p->u.enumItemDecl_.ident_ ),
                                clone_EnumValueOpt( p->u.enumItemDecl_.enumvalueopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EnumItem!\n" );
      exit( 1 );
   }
}

EnumValueOpt clone_EnumValueOpt( EnumValueOpt p )
{
   switch( p->kind )
   {
   case is_OptEnumValueEmpty:
      return make_OptEnumValueEmpty();

   case is_OptEnumValueSome:
      return make_OptEnumValueSome( strdup( p->u.optEnumValueSome_.intlit_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning EnumValueOpt!\n" );
      exit( 1 );
   }
}

LineEolOpt clone_LineEolOpt( LineEolOpt p )
{
   switch( p->kind )
   {
   case is_OptLineEolEmpty:
      return make_OptLineEolEmpty();

   case is_OptLineEolSome:
      return make_OptLineEolSome( strdup( p->u.optLineEolSome_.lineeol_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning LineEolOpt!\n" );
      exit( 1 );
   }
}

StructDecl clone_StructDecl( StructDecl p )
{
   switch( p->kind )
   {
   case is_StructDeclMain:
      return make_StructDeclMain( strdup( p->u.structDeclMain_.ident_ ), strdup( p->u.structDeclMain_.lineeol_ ),
                                  clone_StructBody( p->u.structDeclMain_.structbody_ ),
                                  clone_EndStruct( p->u.structDeclMain_.endstruct_ ),
                                  clone_StmtEnd( p->u.structDeclMain_.stmtend_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StructDecl!\n" );
      exit( 1 );
   }
}

StructBody clone_StructBody( StructBody p )
{
   switch( p->kind )
   {
   case is_StructBodyEmpty:
      return make_StructBodyEmpty();

   case is_StructBodyCons:
      return make_StructBodyCons( clone_StructMember( p->u.structBodyCons_.structmember_ ),
                                  clone_StructBody( p->u.structBodyCons_.structbody_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StructBody!\n" );
      exit( 1 );
   }
}

StructMember clone_StructMember( StructMember p )
{
   switch( p->kind )
   {
   case is_StructMemberVar:
      return make_StructMemberVar( clone_VarList( p->u.structMemberVar_.varlist_ ),
                                   strdup( p->u.structMemberVar_.lineeol_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StructMember!\n" );
      exit( 1 );
   }
}

FieldInitList clone_FieldInitList( FieldInitList p )
{
   switch( p->kind )
   {
   case is_FieldInitListSingle:
      return make_FieldInitListSingle( clone_FieldInit( p->u.fieldInitListSingle_.fieldinit_ ) );

   case is_FieldInitListCons:
      return make_FieldInitListCons( clone_FieldInit( p->u.fieldInitListCons_.fieldinit_ ),
                                     clone_FieldInitList( p->u.fieldInitListCons_.fieldinitlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning FieldInitList!\n" );
      exit( 1 );
   }
}

FieldInit clone_FieldInit( FieldInit p )
{
   switch( p->kind )
   {
   case is_FieldInitItem:
      return make_FieldInitItem( strdup( p->u.fieldInitItem_.ident_ ), clone_Expr( p->u.fieldInitItem_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning FieldInit!\n" );
      exit( 1 );
   }
}

StaticDecl clone_StaticDecl( StaticDecl p )
{
   switch( p->kind )
   {
   case is_StaticStructDecl:
      return make_StaticStructDecl( strdup( p->u.staticStructDecl_.ident_ ),
                                    clone_IdentInitList( p->u.staticStructDecl_.identinitlist_ ),
                                    clone_StmtEnd( p->u.staticStructDecl_.stmtend_ ) );

   case is_StaticDeclItem:
      return make_StaticDeclItem( clone_StaticItemList( p->u.staticDeclItem_.staticitemlist_ ),
                                  clone_StmtEnd( p->u.staticDeclItem_.stmtend_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticDecl!\n" );
      exit( 1 );
   }
}

ClassDecl clone_ClassDecl( ClassDecl p )
{
   switch( p->kind )
   {
   case is_ClassDeclMain:
      return make_ClassDeclMain(
          clone_CreateOpt( p->u.classDeclMain_.createopt_ ), clone_ClassName( p->u.classDeclMain_.classname_ ),
          clone_InheritOpt( p->u.classDeclMain_.inheritopt_ ),
          clone_StaticClassOpt( p->u.classDeclMain_.staticclassopt_ ), strdup( p->u.classDeclMain_.lineeol_ ),
          clone_ClassBody( p->u.classDeclMain_.classbody_ ), clone_EndClass( p->u.classDeclMain_.endclass_ ),
          clone_StmtEnd( p->u.classDeclMain_.stmtend_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ClassDecl!\n" );
      exit( 1 );
   }
}

CreateOpt clone_CreateOpt( CreateOpt p )
{
   switch( p->kind )
   {
   case is_OptCreateEmpty:
      return make_OptCreateEmpty();

   case is_OptCreateSome:
      return make_OptCreateSome();

   default:
      fprintf( stderr, "Error: bad kind field when cloning CreateOpt!\n" );
      exit( 1 );
   }
}

ClassName clone_ClassName( ClassName p )
{
   switch( p->kind )
   {
   case is_ClassNameIdent:
      return make_ClassNameIdent( strdup( p->u.classNameIdent_.ident_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ClassName!\n" );
      exit( 1 );
   }
}

InheritOpt clone_InheritOpt( InheritOpt p )
{
   switch( p->kind )
   {
   case is_OptInheritEmpty:
      return make_OptInheritEmpty();

   case is_OptInheritSome:
      return make_OptInheritSome( clone_InheritKeyword( p->u.optInheritSome_.inheritkeyword_ ),
                                  clone_ClassName( p->u.optInheritSome_.classname_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning InheritOpt!\n" );
      exit( 1 );
   }
}

InheritKeyword clone_InheritKeyword( InheritKeyword p )
{
   switch( p->kind )
   {
   case is_InheritFrom:
      return make_InheritFrom();

   case is_InheritInherit:
      return make_InheritInherit();

   default:
      fprintf( stderr, "Error: bad kind field when cloning InheritKeyword!\n" );
      exit( 1 );
   }
}

StaticClassOpt clone_StaticClassOpt( StaticClassOpt p )
{
   switch( p->kind )
   {
   case is_OptStaticClassEmpty:
      return make_OptStaticClassEmpty();

   case is_OptStaticClassSome:
      return make_OptStaticClassSome();

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticClassOpt!\n" );
      exit( 1 );
   }
}

ClassBody clone_ClassBody( ClassBody p )
{
   switch( p->kind )
   {
   case is_ClassBodyEmpty:
      return make_ClassBodyEmpty();

   case is_ClassBodyCons:
      return make_ClassBodyCons( clone_ClassMember( p->u.classBodyCons_.classmember_ ),
                                 clone_ClassBody( p->u.classBodyCons_.classbody_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ClassBody!\n" );
      exit( 1 );
   }
}

ClassMember clone_ClassMember( ClassMember p )
{
   switch( p->kind )
   {
   case is_ClassMemberVisibility:
      return make_ClassMemberVisibility( clone_VisibilityScope( p->u.classMemberVisibility_.visibilityscope_ ),
                                         strdup( p->u.classMemberVisibility_.lineeol_ ) );

   case is_ClassMemberVar:
      return make_ClassMemberVar( clone_VarList( p->u.classMemberVar_.varlist_ ),
                                  strdup( p->u.classMemberVar_.lineeol_ ) );

   case is_ClassMemberMethod:
      return make_ClassMemberMethod( strdup( p->u.classMemberMethod_.ident_ ),
                                     clone_MethodParamsOpt( p->u.classMemberMethod_.methodparamsopt_ ),
                                     strdup( p->u.classMemberMethod_.lineeol_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ClassMember!\n" );
      exit( 1 );
   }
}

VisibilityScope clone_VisibilityScope( VisibilityScope p )
{
   switch( p->kind )
   {
   case is_VisibilityExported:
      return make_VisibilityExported();

   case is_VisibilityVisible:
      return make_VisibilityVisible();

   case is_VisibilityHidden:
      return make_VisibilityHidden();

   case is_VisibilityProtected:
      return make_VisibilityProtected();

   default:
      fprintf( stderr, "Error: bad kind field when cloning VisibilityScope!\n" );
      exit( 1 );
   }
}

VarList clone_VarList( VarList p )
{
   switch( p->kind )
   {
   case is_VarListSingle:
      return make_VarListSingle( clone_VarDecl( p->u.varListSingle_.vardecl_ ) );

   case is_VarListCons:
      return make_VarListCons( clone_VarDecl( p->u.varListCons_.vardecl_ ),
                               clone_VarList( p->u.varListCons_.varlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning VarList!\n" );
      exit( 1 );
   }
}

VarDecl clone_VarDecl( VarDecl p )
{
   switch( p->kind )
   {
   case is_VarDeclItem:
      return make_VarDeclItem( strdup( p->u.varDeclItem_.ident_ ), clone_VarInitOpt( p->u.varDeclItem_.varinitopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning VarDecl!\n" );
      exit( 1 );
   }
}

VarInitOpt clone_VarInitOpt( VarInitOpt p )
{
   switch( p->kind )
   {
   case is_OptVarInitEmpty:
      return make_OptVarInitEmpty();

   case is_OptVarInitSome:
      return make_OptVarInitSome( clone_Expr( p->u.optVarInitSome_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning VarInitOpt!\n" );
      exit( 1 );
   }
}

MethodParamsOpt clone_MethodParamsOpt( MethodParamsOpt p )
{
   switch( p->kind )
   {
   case is_MethodParamsEmpty:
      return make_MethodParamsEmpty();

   case is_MethodParamsSome:
      return make_MethodParamsSome( clone_ParamListOpt( p->u.methodParamsSome_.paramlistopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning MethodParamsOpt!\n" );
      exit( 1 );
   }
}

Expr clone_Expr( Expr p )
{
   switch( p->kind )
   {
   case is_ExprAssignBase:
      return make_ExprAssignBase( clone_ExprOr( p->u.exprAssignBase_.expror_ ) );

   case is_ExprAndDot:
      return make_ExprAndDot( clone_Expr( p->u.exprAndDot_.expr_1 ), clone_Expr( p->u.exprAndDot_.expr_2 ) );

   case is_ExprAndBase:
      return make_ExprAndBase( clone_Expr( p->u.exprAndBase_.expr_ ) );

   case is_ExprNotDot:
      return make_ExprNotDot( clone_Expr( p->u.exprNotDot_.expr_ ) );

   case is_ExprNotBase:
      return make_ExprNotBase( clone_Expr( p->u.exprNotBase_.expr_ ) );

   case is_ExprEq:
      return make_ExprEq( clone_Expr( p->u.exprEq_.expr_1 ), clone_Expr( p->u.exprEq_.expr_2 ) );

   case is_ExprEq2:
      return make_ExprEq2( clone_Expr( p->u.exprEq2_.expr_1 ), clone_Expr( p->u.exprEq2_.expr_2 ) );

   case is_ExprNeq:
      return make_ExprNeq( clone_Expr( p->u.exprNeq_.expr_1 ), clone_Expr( p->u.exprNeq_.expr_2 ) );

   case is_ExprNeq2:
      return make_ExprNeq2( clone_Expr( p->u.exprNeq2_.expr_1 ), clone_Expr( p->u.exprNeq2_.expr_2 ) );

   case is_ExprNeq3:
      return make_ExprNeq3( clone_Expr( p->u.exprNeq3_.expr_1 ), clone_Expr( p->u.exprNeq3_.expr_2 ) );

   case is_ExprLt:
      return make_ExprLt( clone_Expr( p->u.exprLt_.expr_1 ), clone_Expr( p->u.exprLt_.expr_2 ) );

   case is_ExprLe:
      return make_ExprLe( clone_Expr( p->u.exprLe_.expr_1 ), clone_Expr( p->u.exprLe_.expr_2 ) );

   case is_ExprGt:
      return make_ExprGt( clone_Expr( p->u.exprGt_.expr_1 ), clone_Expr( p->u.exprGt_.expr_2 ) );

   case is_ExprGe:
      return make_ExprGe( clone_Expr( p->u.exprGe_.expr_1 ), clone_Expr( p->u.exprGe_.expr_2 ) );

   case is_ExprSubStr:
      return make_ExprSubStr( clone_Expr( p->u.exprSubStr_.expr_1 ), clone_Expr( p->u.exprSubStr_.expr_2 ) );

   case is_ExprRelBase:
      return make_ExprRelBase( clone_Expr( p->u.exprRelBase_.expr_ ) );

   case is_ExprAdd:
      return make_ExprAdd( clone_Expr( p->u.exprAdd_.expr_1 ), clone_Expr( p->u.exprAdd_.expr_2 ) );

   case is_ExprSub:
      return make_ExprSub( clone_Expr( p->u.exprSub_.expr_1 ), clone_Expr( p->u.exprSub_.expr_2 ) );

   case is_ExprAddBase:
      return make_ExprAddBase( clone_Expr( p->u.exprAddBase_.expr_ ) );

   case is_ExprMul:
      return make_ExprMul( clone_Expr( p->u.exprMul_.expr_1 ), clone_Expr( p->u.exprMul_.expr_2 ) );

   case is_ExprDiv:
      return make_ExprDiv( clone_Expr( p->u.exprDiv_.expr_1 ), clone_Expr( p->u.exprDiv_.expr_2 ) );

   case is_ExprMod:
      return make_ExprMod( clone_Expr( p->u.exprMod_.expr_1 ), clone_Expr( p->u.exprMod_.expr_2 ) );

   case is_ExprMulBase:
      return make_ExprMulBase( clone_Expr( p->u.exprMulBase_.expr_ ) );

   case is_ExprPow1:
      return make_ExprPow1( clone_Expr( p->u.exprPow1_.expr_1 ), clone_Expr( p->u.exprPow1_.expr_2 ) );

   case is_ExprPow2:
      return make_ExprPow2( clone_Expr( p->u.exprPow2_.expr_1 ), clone_Expr( p->u.exprPow2_.expr_2 ) );

   case is_ExprPowBase:
      return make_ExprPowBase( clone_Expr( p->u.exprPowBase_.expr_ ) );

   case is_ExprAddrOf:
      return make_ExprAddrOf( clone_LHS( p->u.exprAddrOf_.lhs_ ) );

   case is_ExprDeref:
      return make_ExprDeref( clone_Expr( p->u.exprDeref_.expr_ ) );

   case is_ExprDecPre:
      return make_ExprDecPre( clone_Expr( p->u.exprDecPre_.expr_ ) );

   case is_ExprIncPre:
      return make_ExprIncPre( clone_Expr( p->u.exprIncPre_.expr_ ) );

   case is_ExprPlus:
      return make_ExprPlus( clone_Expr( p->u.exprPlus_.expr_ ) );

   case is_ExprMinus:
      return make_ExprMinus( clone_Expr( p->u.exprMinus_.expr_ ) );

   case is_ExprSignBase:
      return make_ExprSignBase( clone_Expr( p->u.exprSignBase_.expr_ ) );

   case is_ExprLit:
      return make_ExprLit( clone_Literal( p->u.exprLit_.literal_ ) );

   case is_ExprCall:
      return make_ExprCall( clone_CallExpr( p->u.exprCall_.callexpr_ ) );

   case is_ExprQId:
      return make_ExprQId( clone_QualifiedId( p->u.exprQId_.qualifiedid_ ) );

   case is_ExprParen:
      return make_ExprParen( clone_Expr( p->u.exprParen_.expr_ ) );

   case is_ExprIndex:
      return make_ExprIndex( clone_Expr( p->u.exprIndex_.expr_ ),
                             clone_SubscriptList( p->u.exprIndex_.subscriptlist_ ) );

   case is_ExprArray:
      return make_ExprArray( clone_ExprListOpt( p->u.exprArray_.exprlistopt_ ) );

   case is_ExprBlock:
      return make_ExprBlock( clone_ParamListOpt( p->u.exprBlock_.paramlistopt_ ),
                             clone_ExprListOpt( p->u.exprBlock_.exprlistopt_ ) );

   case is_ExprMethodCall:
      return make_ExprMethodCall( clone_Expr( p->u.exprMethodCall_.expr_ ), strdup( p->u.exprMethodCall_.ident_ ),
                                  clone_ArgListOpt( p->u.exprMethodCall_.arglistopt_ ) );

   case is_ExprFieldAccess:
      return make_ExprFieldAccess( clone_Expr( p->u.exprFieldAccess_.expr_ ), strdup( p->u.exprFieldAccess_.ident_ ) );

   case is_ExprStructInitNamed:
      return make_ExprStructInitNamed( clone_QualifiedId( p->u.exprStructInitNamed_.qualifiedid_ ),
                                       clone_FieldInitList( p->u.exprStructInitNamed_.fieldinitlist_ ) );

   case is_ExprStructAnon:
      return make_ExprStructAnon( clone_FieldInitList( p->u.exprStructAnon_.fieldinitlist_ ) );

   case is_ExprDecPost:
      return make_ExprDecPost( clone_Expr( p->u.exprDecPost_.expr_ ) );

   case is_ExprIncPost:
      return make_ExprIncPost( clone_Expr( p->u.exprIncPost_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning Expr!\n" );
      exit( 1 );
   }
}

ExprOr clone_ExprOr( ExprOr p )
{
   switch( p->kind )
   {
   case is_ExprOrDot:
      return make_ExprOrDot( clone_ExprOr( p->u.exprOrDot_.expror_ ), clone_Expr( p->u.exprOrDot_.expr_ ) );

   case is_ExprOrBase:
      return make_ExprOrBase( clone_Expr( p->u.exprOrBase_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ExprOr!\n" );
      exit( 1 );
   }
}

CallExpr clone_CallExpr( CallExpr p )
{
   switch( p->kind )
   {
   case is_CallExprMain:
      return make_CallExprMain( clone_QualifiedId( p->u.callExprMain_.qualifiedid_ ),
                                clone_ArgListOpt( p->u.callExprMain_.arglistopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning CallExpr!\n" );
      exit( 1 );
   }
}

ArgListOpt clone_ArgListOpt( ArgListOpt p )
{
   switch( p->kind )
   {
   case is_OptArgListEmpty:
      return make_OptArgListEmpty();

   case is_OptArgListSome:
      return make_OptArgListSome( clone_Expr( p->u.optArgListSome_.expr_ ),
                                  clone_ArgListTail( p->u.optArgListSome_.arglisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ArgListOpt!\n" );
      exit( 1 );
   }
}

ArgListTail clone_ArgListTail( ArgListTail p )
{
   switch( p->kind )
   {
   case is_ListArgTailEmpty:
      return make_ListArgTailEmpty();

   case is_ListArgTailCons:
      return make_ListArgTailCons( clone_Expr( p->u.listArgTailCons_.expr_ ),
                                   clone_ArgListTail( p->u.listArgTailCons_.arglisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ArgListTail!\n" );
      exit( 1 );
   }
}

ExprListOpt clone_ExprListOpt( ExprListOpt p )
{
   switch( p->kind )
   {
   case is_OptExprListEmpty:
      return make_OptExprListEmpty();

   case is_OptExprListSome:
      return make_OptExprListSome( clone_Expr( p->u.optExprListSome_.expr_ ),
                                   clone_ExprListTail( p->u.optExprListSome_.exprlisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ExprListOpt!\n" );
      exit( 1 );
   }
}

ExprListTail clone_ExprListTail( ExprListTail p )
{
   switch( p->kind )
   {
   case is_ListExprTailEmpty:
      return make_ListExprTailEmpty();

   case is_ListExprTailCons:
      return make_ListExprTailCons( clone_Expr( p->u.listExprTailCons_.expr_ ),
                                    clone_ExprListTail( p->u.listExprTailCons_.exprlisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ExprListTail!\n" );
      exit( 1 );
   }
}

QualifiedId clone_QualifiedId( QualifiedId p )
{
   switch( p->kind )
   {
   case is_QualifiedIdSingle:
      return make_QualifiedIdSingle( strdup( p->u.qualifiedIdSingle_.ident_ ) );

   case is_QualifiedIdMore:
      return make_QualifiedIdMore( strdup( p->u.qualifiedIdMore_.ident_ ),
                                   clone_QualifiedId( p->u.qualifiedIdMore_.qualifiedid_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning QualifiedId!\n" );
      exit( 1 );
   }
}

LHS clone_LHS( LHS p )
{
   switch( p->kind )
   {
   case is_LHSVal:
      return make_LHSVal( clone_LValue( p->u.lHSVal_.lvalue_ ) );

   case is_LHSDeref:
      return make_LHSDeref( clone_Expr( p->u.lHSDeref_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning LHS!\n" );
      exit( 1 );
   }
}

LValue clone_LValue( LValue p )
{
   switch( p->kind )
   {
   case is_LValQId:
      return make_LValQId( clone_QualifiedId( p->u.lValQId_.qualifiedid_ ) );

   case is_LValField:
      return make_LValField( clone_LValue( p->u.lValField_.lvalue_ ), strdup( p->u.lValField_.ident_ ) );

   case is_LValIndex:
      return make_LValIndex( clone_LValue( p->u.lValIndex_.lvalue_ ),
                             clone_SubscriptList( p->u.lValIndex_.subscriptlist_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning LValue!\n" );
      exit( 1 );
   }
}

SubscriptList clone_SubscriptList( SubscriptList p )
{
   switch( p->kind )
   {
   case is_SubscriptListSingle:
      return make_SubscriptListSingle( clone_Expr( p->u.subscriptListSingle_.expr_ ),
                                       clone_SubscriptListTail( p->u.subscriptListSingle_.subscriptlisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning SubscriptList!\n" );
      exit( 1 );
   }
}

SubscriptListTail clone_SubscriptListTail( SubscriptListTail p )
{
   switch( p->kind )
   {
   case is_ListSubscriptTailEmpty:
      return make_ListSubscriptTailEmpty();

   case is_ListSubscriptTailCons:
      return make_ListSubscriptTailCons( clone_Expr( p->u.listSubscriptTailCons_.expr_ ),
                                         clone_SubscriptListTail( p->u.listSubscriptTailCons_.subscriptlisttail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning SubscriptListTail!\n" );
      exit( 1 );
   }
}

Literal clone_Literal( Literal p )
{
   switch( p->kind )
   {
   case is_LitNil:
      return make_LitNil();

   case is_LitTrueDot:
      return make_LitTrueDot();

   case is_LitFalseDot:
      return make_LitFalseDot();

   case is_LitInt:
      return make_LitInt( strdup( p->u.litInt_.intlit_ ) );

   case is_LitFloat:
      return make_LitFloat( strdup( p->u.litFloat_.floatlit_ ) );

   case is_LitStr:
      return make_LitStr( clone_Napis( p->u.litStr_.napis_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning Literal!\n" );
      exit( 1 );
   }
}

Napis clone_Napis( Napis p )
{
   switch( p->kind )
   {
   case is_NapisStr:
      return make_NapisStr( strdup( p->u.napisStr_.strlit_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning Napis!\n" );
      exit( 1 );
   }
}

Def clone_Def( Def p )
{
   switch( p->kind )
   {
   case is_DefFun:
      return make_DefFun( clone_FunctionDef( p->u.defFun_.functiondef_ ) );

   case is_DefProc:
      return make_DefProc( clone_ProcedureDef( p->u.defProc_.proceduredef_ ) );

   case is_DefMeth:
      return make_DefMeth( clone_MethodDef( p->u.defMeth_.methoddef_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning Def!\n" );
      exit( 1 );
   }
}

FunctionDef clone_FunctionDef( FunctionDef p )
{
   switch( p->kind )
   {
   case is_FunctionDefMain:
      return make_FunctionDefMain(
          clone_StaticOpt( p->u.functionDefMain_.staticopt_ ), strdup( p->u.functionDefMain_.ident_ ),
          clone_ParamListOpt( p->u.functionDefMain_.paramlistopt_ ), strdup( p->u.functionDefMain_.lineeol_ ),
          clone_LocalDeclsOpt( p->u.functionDefMain_.localdeclsopt_ ),
          clone_StaticDeclsOpt( p->u.functionDefMain_.staticdeclsopt_ ),
          clone_StmtListNonEmpty( p->u.functionDefMain_.stmtlistnonempty_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning FunctionDef!\n" );
      exit( 1 );
   }
}

ProcedureDef clone_ProcedureDef( ProcedureDef p )
{
   switch( p->kind )
   {
   case is_ProcedureDefMain:
      return make_ProcedureDefMain(
          clone_StaticOpt( p->u.procedureDefMain_.staticopt_ ), strdup( p->u.procedureDefMain_.ident_ ),
          clone_ParamListOpt( p->u.procedureDefMain_.paramlistopt_ ), strdup( p->u.procedureDefMain_.lineeol_ ),
          clone_LocalDeclsOpt( p->u.procedureDefMain_.localdeclsopt_ ),
          clone_StaticDeclsOpt( p->u.procedureDefMain_.staticdeclsopt_ ),
          clone_StmtListNonEmpty( p->u.procedureDefMain_.stmtlistnonempty_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning ProcedureDef!\n" );
      exit( 1 );
   }
}

StaticOpt clone_StaticOpt( StaticOpt p )
{
   switch( p->kind )
   {
   case is_OptStaticEmpty:
      return make_OptStaticEmpty();

   case is_OptStaticSome:
      return make_OptStaticSome();

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticOpt!\n" );
      exit( 1 );
   }
}

LocalDeclsOpt clone_LocalDeclsOpt( LocalDeclsOpt p )
{
   switch( p->kind )
   {
   case is_ListLocalDeclEmpty:
      return make_ListLocalDeclEmpty();

   case is_ListLocalDeclLine:
      return make_ListLocalDeclLine( strdup( p->u.listLocalDeclLine_.lineeol_ ),
                                     clone_LocalDeclsOpt( p->u.listLocalDeclLine_.localdeclsopt_ ) );

   case is_ListLocalDeclCons:
      return make_ListLocalDeclCons( clone_LocalDecl( p->u.listLocalDeclCons_.localdecl_ ),
                                     clone_LocalDeclsOpt( p->u.listLocalDeclCons_.localdeclsopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning LocalDeclsOpt!\n" );
      exit( 1 );
   }
}

LocalDecl clone_LocalDecl( LocalDecl p )
{
   switch( p->kind )
   {
   case is_LocalDeclItem:
      return make_LocalDeclItem( clone_IdentInitList( p->u.localDeclItem_.identinitlist_ ),
                                 clone_StmtEnd( p->u.localDeclItem_.stmtend_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning LocalDecl!\n" );
      exit( 1 );
   }
}

StaticDeclsOpt clone_StaticDeclsOpt( StaticDeclsOpt p )
{
   switch( p->kind )
   {
   case is_ListStaticDeclEmpty:
      return make_ListStaticDeclEmpty();

   case is_ListStaticDeclCons:
      return make_ListStaticDeclCons( clone_StaticDecl( p->u.listStaticDeclCons_.staticdecl_ ),
                                      clone_StaticDeclsOpt( p->u.listStaticDeclCons_.staticdeclsopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticDeclsOpt!\n" );
      exit( 1 );
   }
}

StaticItemList clone_StaticItemList( StaticItemList p )
{
   switch( p->kind )
   {
   case is_StaticItemListSingle:
      return make_StaticItemListSingle( clone_StaticItem( p->u.staticItemListSingle_.staticitem_ ),
                                        clone_StaticItemTail( p->u.staticItemListSingle_.staticitemtail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticItemList!\n" );
      exit( 1 );
   }
}

StaticItemTail clone_StaticItemTail( StaticItemTail p )
{
   switch( p->kind )
   {
   case is_StaticItemTailEmpty:
      return make_StaticItemTailEmpty();

   case is_StaticItemTailCons:
      return make_StaticItemTailCons( clone_StaticItem( p->u.staticItemTailCons_.staticitem_ ),
                                      clone_StaticItemTail( p->u.staticItemTailCons_.staticitemtail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticItemTail!\n" );
      exit( 1 );
   }
}

StaticItem clone_StaticItem( StaticItem p )
{
   switch( p->kind )
   {
   case is_StaticItemMain:
      return make_StaticItemMain( strdup( p->u.staticItemMain_.ident_ ),
                                  clone_StaticArrayDimsOpt( p->u.staticItemMain_.staticarraydimsopt_ ),
                                  clone_StaticInitOpt( p->u.staticItemMain_.staticinitopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticItem!\n" );
      exit( 1 );
   }
}

StaticArrayDimsOpt clone_StaticArrayDimsOpt( StaticArrayDimsOpt p )
{
   switch( p->kind )
   {
   case is_StaticArrayDimsEmpty:
      return make_StaticArrayDimsEmpty();

   case is_StaticArrayDimsCons:
      return make_StaticArrayDimsCons( clone_SubscriptList( p->u.staticArrayDimsCons_.subscriptlist_ ),
                                       clone_StaticArrayDimsOpt( p->u.staticArrayDimsCons_.staticarraydimsopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticArrayDimsOpt!\n" );
      exit( 1 );
   }
}

StaticInitOpt clone_StaticInitOpt( StaticInitOpt p )
{
   switch( p->kind )
   {
   case is_StaticInitEmpty:
      return make_StaticInitEmpty();

   case is_StaticInitSome:
      return make_StaticInitSome( clone_Expr( p->u.staticInitSome_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning StaticInitOpt!\n" );
      exit( 1 );
   }
}

IdentInitList clone_IdentInitList( IdentInitList p )
{
   switch( p->kind )
   {
   case is_ListIdentInitSingle:
      return make_ListIdentInitSingle( clone_IdentInit( p->u.listIdentInitSingle_.identinit_ ),
                                       clone_IdentInitTail( p->u.listIdentInitSingle_.identinittail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning IdentInitList!\n" );
      exit( 1 );
   }
}

IdentInitTail clone_IdentInitTail( IdentInitTail p )
{
   switch( p->kind )
   {
   case is_ListIdentInitTailEmpty:
      return make_ListIdentInitTailEmpty();

   case is_ListIdentInitTailCons:
      return make_ListIdentInitTailCons( clone_IdentInit( p->u.listIdentInitTailCons_.identinit_ ),
                                         clone_IdentInitTail( p->u.listIdentInitTailCons_.identinittail_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning IdentInitTail!\n" );
      exit( 1 );
   }
}

IdentInit clone_IdentInit( IdentInit p )
{
   switch( p->kind )
   {
   case is_IdentInitItem:
      return make_IdentInitItem( strdup( p->u.identInitItem_.ident_ ), clone_InitOpt( p->u.identInitItem_.initopt_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning IdentInit!\n" );
      exit( 1 );
   }
}

InitOpt clone_InitOpt( InitOpt p )
{
   switch( p->kind )
   {
   case is_OptInitEmpty:
      return make_OptInitEmpty();

   case is_OptInitSome:
      return make_OptInitSome( clone_Expr( p->u.optInitSome_.expr_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning InitOpt!\n" );
      exit( 1 );
   }
}

MethodDef clone_MethodDef( MethodDef p )
{
   switch( p->kind )
   {
   case is_MethodDefMain:
      return make_MethodDefMain(
          clone_StaticOpt( p->u.methodDefMain_.staticopt_ ), strdup( p->u.methodDefMain_.ident_ ),
          clone_ParamListOpt( p->u.methodDefMain_.paramlistopt_ ), clone_ClassName( p->u.methodDefMain_.classname_ ),
          strdup( p->u.methodDefMain_.lineeol_ ), clone_LocalDeclsOpt( p->u.methodDefMain_.localdeclsopt_ ),
          clone_StaticDeclsOpt( p->u.methodDefMain_.staticdeclsopt_ ),
          clone_StmtListNonEmpty( p->u.methodDefMain_.stmtlistnonempty_ ) );

   default:
      fprintf( stderr, "Error: bad kind field when cloning MethodDef!\n" );
      exit( 1 );
   }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Program( Program p )
{
   switch( p->kind )
   {
   case is_ProgramRoot:
      free_LeadingEols( p->u.programRoot_.leadingeols_ );
      free_TopDecls( p->u.programRoot_.topdecls_ );
      free_Defs( p->u.programRoot_.defs_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing Program!\n" );
      exit( 1 );
   }
   free( p );
}

void free_LeadingEols( LeadingEols p )
{
   switch( p->kind )
   {
   case is_LeadingEolsEmpty:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing LeadingEols!\n" );
      exit( 1 );
   }
   free( p );
}

void free_TopDecls( TopDecls p )
{
   switch( p->kind )
   {
   case is_ListTopDeclEmpty:
      break;

   case is_ListTopDeclCons:
      free_TopDecl( p->u.listTopDeclCons_.topdecl_ );
      free_TopDecls( p->u.listTopDeclCons_.topdecls_ );
      break;

   case is_ListTopDeclLine:
      free( p->u.listTopDeclLine_.lineeol_ );
      free_TopDecls( p->u.listTopDeclLine_.topdecls_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing TopDecls!\n" );
      exit( 1 );
   }
   free( p );
}

void free_TopDecl( TopDecl p )
{
   switch( p->kind )
   {
   case is_TopDeclEnum:
      free_EnumDecl( p->u.topDeclEnum_.enumdecl_ );
      break;

   case is_TopDeclClass:
      free_ClassDecl( p->u.topDeclClass_.classdecl_ );
      break;

   case is_TopDeclStruct:
      free_StructDecl( p->u.topDeclStruct_.structdecl_ );
      break;

   case is_TopDeclPreproc:
      free_PreprocDecl( p->u.topDeclPreproc_.preprocdecl_ );
      break;

   case is_TopDeclStatic:
      free_StaticDecl( p->u.topDeclStatic_.staticdecl_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing TopDecl!\n" );
      exit( 1 );
   }
   free( p );
}

void free_Defs( Defs p )
{
   switch( p->kind )
   {
   case is_ListDefSingle:
      free_Def( p->u.listDefSingle_.def_ );
      break;

   case is_ListDefCons:
      free_Def( p->u.listDefCons_.def_ );
      free_Defs( p->u.listDefCons_.defs_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing Defs!\n" );
      exit( 1 );
   }
   free( p );
}

void free_PreprocDecl( PreprocDecl p )
{
   switch( p->kind )
   {
   case is_PreprocDeclLine:
      free( p->u.preprocDeclLine_.preprocline_ );
      free_StmtEnd( p->u.preprocDeclLine_.stmtend_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing PreprocDecl!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ParamListOpt( ParamListOpt p )
{
   switch( p->kind )
   {
   case is_OptParamListEmpty:
      break;

   case is_OptParamListSome:
      free( p->u.optParamListSome_.ident_ );
      free_ParamListTail( p->u.optParamListSome_.paramlisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ParamListOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ParamListTail( ParamListTail p )
{
   switch( p->kind )
   {
   case is_ListParamTailEmpty:
      break;

   case is_ListParamTailCons:
      free( p->u.listParamTailCons_.ident_ );
      free_ParamListTail( p->u.listParamTailCons_.paramlisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ParamListTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_Stmt( Stmt p )
{
   switch( p->kind )
   {
   case is_StmtAssignInl:
      free_LHS( p->u.stmtAssignInl_.lhs_ );
      free_Expr( p->u.stmtAssignInl_.expr_ );
      free_StmtEnd( p->u.stmtAssignInl_.stmtend_ );
      break;

   case is_StmtAssignAdd:
      free_LHS( p->u.stmtAssignAdd_.lhs_ );
      free_Expr( p->u.stmtAssignAdd_.expr_ );
      free_StmtEnd( p->u.stmtAssignAdd_.stmtend_ );
      break;

   case is_StmtAssignSub:
      free_LHS( p->u.stmtAssignSub_.lhs_ );
      free_Expr( p->u.stmtAssignSub_.expr_ );
      free_StmtEnd( p->u.stmtAssignSub_.stmtend_ );
      break;

   case is_StmtAssignMul:
      free_LHS( p->u.stmtAssignMul_.lhs_ );
      free_Expr( p->u.stmtAssignMul_.expr_ );
      free_StmtEnd( p->u.stmtAssignMul_.stmtend_ );
      break;

   case is_StmtAssignDiv:
      free_LHS( p->u.stmtAssignDiv_.lhs_ );
      free_Expr( p->u.stmtAssignDiv_.expr_ );
      free_StmtEnd( p->u.stmtAssignDiv_.stmtend_ );
      break;

   case is_StmtAssignMod:
      free_LHS( p->u.stmtAssignMod_.lhs_ );
      free_Expr( p->u.stmtAssignMod_.expr_ );
      free_StmtEnd( p->u.stmtAssignMod_.stmtend_ );
      break;

   case is_StmtAssignPow:
      free_LHS( p->u.stmtAssignPow_.lhs_ );
      free_Expr( p->u.stmtAssignPow_.expr_ );
      free_StmtEnd( p->u.stmtAssignPow_.stmtend_ );
      break;

   case is_StmtAssignPow2:
      free_LHS( p->u.stmtAssignPow2_.lhs_ );
      free_Expr( p->u.stmtAssignPow2_.expr_ );
      free_StmtEnd( p->u.stmtAssignPow2_.stmtend_ );
      break;

   case is_StmtCall:
      free_CallExpr( p->u.stmtCall_.callexpr_ );
      free_StmtEnd( p->u.stmtCall_.stmtend_ );
      break;

   case is_StmtIf:
      free_IfCond( p->u.stmtIf_.ifcond_ );
      free( p->u.stmtIf_.lineeol_ );
      free_StmtList( p->u.stmtIf_.stmtlist_ );
      free_ElseIfList( p->u.stmtIf_.elseiflist_ );
      free_ElseOpt( p->u.stmtIf_.elseopt_ );
      free_EndIf( p->u.stmtIf_.endif_ );
      free_StmtEnd( p->u.stmtIf_.stmtend_ );
      break;

   case is_StmtDoWhile:
      free_DoOpt( p->u.stmtDoWhile_.doopt_ );
      free_WhileCond( p->u.stmtDoWhile_.whilecond_ );
      free( p->u.stmtDoWhile_.lineeol_ );
      free_StmtList( p->u.stmtDoWhile_.stmtlist_ );
      free_EndDo( p->u.stmtDoWhile_.enddo_ );
      free_StmtEnd( p->u.stmtDoWhile_.stmtend_ );
      break;

   case is_StmtFor:
      free( p->u.stmtFor_.ident_ );
      free_Expr( p->u.stmtFor_.expr_1 );
      free_Expr( p->u.stmtFor_.expr_2 );
      free_StepOpt( p->u.stmtFor_.stepopt_ );
      free( p->u.stmtFor_.lineeol_ );
      free_StmtList( p->u.stmtFor_.stmtlist_ );
      free_EndFor( p->u.stmtFor_.endfor_ );
      free_StmtEnd( p->u.stmtFor_.stmtend_ );
      break;

   case is_StmtForEach:
      free_ForEachVars( p->u.stmtForEach_.foreachvars_ );
      free_ForEachExprs( p->u.stmtForEach_.foreachexprs_ );
      free_ForEachDescOpt( p->u.stmtForEach_.foreachdescopt_ );
      free( p->u.stmtForEach_.lineeol_ );
      free_StmtList( p->u.stmtForEach_.stmtlist_ );
      free_EndFor( p->u.stmtForEach_.endfor_ );
      free_StmtEnd( p->u.stmtForEach_.stmtend_ );
      break;

   case is_StmtSwitch:
      free_SwitchCond( p->u.stmtSwitch_.switchcond_ );
      free( p->u.stmtSwitch_.lineeol_ );
      free_CaseList( p->u.stmtSwitch_.caselist_ );
      free_OtherwiseOpt( p->u.stmtSwitch_.otherwiseopt_ );
      free_EndSwitch( p->u.stmtSwitch_.endswitch_ );
      free_StmtEnd( p->u.stmtSwitch_.stmtend_ );
      break;

   case is_StmtDoCase:
      free( p->u.stmtDoCase_.lineeol_ );
      free_CaseCondList( p->u.stmtDoCase_.casecondlist_ );
      free_OtherwiseOpt( p->u.stmtDoCase_.otherwiseopt_ );
      free_EndCase( p->u.stmtDoCase_.endcase_ );
      free_StmtEnd( p->u.stmtDoCase_.stmtend_ );
      break;

   case is_StmtSequence:
      free( p->u.stmtSequence_.lineeol_ );
      free_StmtList( p->u.stmtSequence_.stmtlist_ );
      free_RecoverOpt( p->u.stmtSequence_.recoveropt_ );
      free_EndSequence( p->u.stmtSequence_.endsequence_ );
      free_StmtEnd( p->u.stmtSequence_.stmtend_ );
      break;

   case is_StmtBreak:
      free_BreakExprOpt( p->u.stmtBreak_.breakexpropt_ );
      free_StmtEnd( p->u.stmtBreak_.stmtend_ );
      break;

   case is_StmtExit:
      free_StmtEnd( p->u.stmtExit_.stmtend_ );
      break;

   case is_StmtLoop:
      free_StmtEnd( p->u.stmtLoop_.stmtend_ );
      break;

   case is_StmtReturn:
      free_ReturnExprOpt( p->u.stmtReturn_.returnexpropt_ );
      free_StmtEnd( p->u.stmtReturn_.stmtend_ );
      break;

   case is_StmtStructDecl:
      free_StructDecl( p->u.stmtStructDecl_.structdecl_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing Stmt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ReturnExprOpt( ReturnExprOpt p )
{
   switch( p->kind )
   {
   case is_ReturnExprOptEmpty:
      break;

   case is_ReturnExprOptSome:
      free_Expr( p->u.returnExprOptSome_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ReturnExprOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StmtList( StmtList p )
{
   switch( p->kind )
   {
   case is_ListStmtEmpty:
      break;

   case is_ListStmtCons:
      free_Stmt( p->u.listStmtCons_.stmt_ );
      free_StmtList( p->u.listStmtCons_.stmtlist_ );
      break;

   case is_ListStmtLine:
      free( p->u.listStmtLine_.lineeol_ );
      free_StmtList( p->u.listStmtLine_.stmtlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StmtList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StmtListNonEmpty( StmtListNonEmpty p )
{
   switch( p->kind )
   {
   case is_ListStmtNonEmpty:
      free_Stmt( p->u.listStmtNonEmpty_.stmt_ );
      free_StmtList( p->u.listStmtNonEmpty_.stmtlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StmtListNonEmpty!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ElseIfList( ElseIfList p )
{
   switch( p->kind )
   {
   case is_ListElseIfEmpty:
      break;

   case is_ListElseIfCons:
      free_ElseIf( p->u.listElseIfCons_.elseif_ );
      free_ElseIfList( p->u.listElseIfCons_.elseiflist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ElseIfList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ElseIf( ElseIf p )
{
   switch( p->kind )
   {
   case is_ElseIfClause:
      free_IfCond( p->u.elseIfClause_.ifcond_ );
      free( p->u.elseIfClause_.lineeol_ );
      free_StmtList( p->u.elseIfClause_.stmtlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ElseIf!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ElseOpt( ElseOpt p )
{
   switch( p->kind )
   {
   case is_OptElseEmpty:
      break;

   case is_OptElseSome:
      free( p->u.optElseSome_.lineeol_ );
      free_StmtList( p->u.optElseSome_.stmtlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ElseOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_IfCond( IfCond p )
{
   switch( p->kind )
   {
   case is_IfCondExpr:
      free_Expr( p->u.ifCondExpr_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing IfCond!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndIf( EndIf p )
{
   switch( p->kind )
   {
   case is_EndIfWord:
      break;

   case is_EndIfClause:
      free_EndIfOpt( p->u.endIfClause_.endifopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndIf!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndIfOpt( EndIfOpt p )
{
   switch( p->kind )
   {
   case is_EndIfOptEmpty:
      break;

   case is_EndIfOptIf:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndIfOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_DoOpt( DoOpt p )
{
   switch( p->kind )
   {
   case is_DoOptEmpty:
      break;

   case is_DoOptDo:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing DoOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_WhileCond( WhileCond p )
{
   switch( p->kind )
   {
   case is_WhileCondExpr:
      free_Expr( p->u.whileCondExpr_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing WhileCond!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndDo( EndDo p )
{
   switch( p->kind )
   {
   case is_EndDoWord:
      break;

   case is_EndWhileWord:
      break;

   case is_EndDoClause:
      free_EndDoOpt( p->u.endDoClause_.enddoopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndDo!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndDoOpt( EndDoOpt p )
{
   switch( p->kind )
   {
   case is_EndDoOptEmpty:
      break;

   case is_EndDoOptDo:
      break;

   case is_EndDoOptWhile:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndDoOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndCase( EndCase p )
{
   switch( p->kind )
   {
   case is_EndCaseWord:
      break;

   case is_EndCaseClause:
      free_EndCaseOpt( p->u.endCaseClause_.endcaseopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndCase!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndCaseOpt( EndCaseOpt p )
{
   switch( p->kind )
   {
   case is_EndCaseOptEmpty:
      break;

   case is_EndCaseOptCase:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndCaseOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StepOpt( StepOpt p )
{
   switch( p->kind )
   {
   case is_OptStepEmpty:
      break;

   case is_OptStepSome:
      free_Expr( p->u.optStepSome_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StepOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndFor( EndFor p )
{
   switch( p->kind )
   {
   case is_EndForWord:
      break;

   case is_EndForClause:
      free_EndForOpt( p->u.endForClause_.endforopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndFor!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndForOpt( EndForOpt p )
{
   switch( p->kind )
   {
   case is_EndForOptEmpty:
      break;

   case is_EndForOptFor:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndForOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ForEachVars( ForEachVars p )
{
   switch( p->kind )
   {
   case is_ForEachVarsMain:
      free( p->u.forEachVarsMain_.ident_ );
      free_ForEachVarsTail( p->u.forEachVarsMain_.foreachvarstail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ForEachVars!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ForEachVarsTail( ForEachVarsTail p )
{
   switch( p->kind )
   {
   case is_ListForEachVarsTailEmpty:
      break;

   case is_ListForEachVarsTailCons:
      free( p->u.listForEachVarsTailCons_.ident_ );
      free_ForEachVarsTail( p->u.listForEachVarsTailCons_.foreachvarstail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ForEachVarsTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ForEachExprs( ForEachExprs p )
{
   switch( p->kind )
   {
   case is_ForEachExprsMain:
      free_Expr( p->u.forEachExprsMain_.expr_ );
      free_ForEachExprsTail( p->u.forEachExprsMain_.foreachexprstail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ForEachExprs!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ForEachExprsTail( ForEachExprsTail p )
{
   switch( p->kind )
   {
   case is_ListForEachExprsTailEmpty:
      break;

   case is_ListForEachExprsTailCons:
      free_Expr( p->u.listForEachExprsTailCons_.expr_ );
      free_ForEachExprsTail( p->u.listForEachExprsTailCons_.foreachexprstail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ForEachExprsTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ForEachDescOpt( ForEachDescOpt p )
{
   switch( p->kind )
   {
   case is_ForEachDescOptEmpty:
      break;

   case is_ForEachDescOptSome:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ForEachDescOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_CaseList( CaseList p )
{
   switch( p->kind )
   {
   case is_ListCaseEmpty:
      break;

   case is_ListCaseCons:
      free_CaseClause( p->u.listCaseCons_.caseclause_ );
      free_CaseList( p->u.listCaseCons_.caselist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing CaseList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_CaseClause( CaseClause p )
{
   switch( p->kind )
   {
   case is_CaseClauseItem:
      free_CaseValue( p->u.caseClauseItem_.casevalue_ );
      free( p->u.caseClauseItem_.lineeol_ );
      free_StmtList( p->u.caseClauseItem_.stmtlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing CaseClause!\n" );
      exit( 1 );
   }
   free( p );
}

void free_CaseCondList( CaseCondList p )
{
   switch( p->kind )
   {
   case is_ListCaseCondEmpty:
      break;

   case is_ListCaseCondCons:
      free_CaseCondClause( p->u.listCaseCondCons_.casecondclause_ );
      free_CaseCondList( p->u.listCaseCondCons_.casecondlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing CaseCondList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_CaseCondClause( CaseCondClause p )
{
   switch( p->kind )
   {
   case is_CaseCondClauseItem:
      free_Expr( p->u.caseCondClauseItem_.expr_ );
      free( p->u.caseCondClauseItem_.lineeol_ );
      free_StmtList( p->u.caseCondClauseItem_.stmtlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing CaseCondClause!\n" );
      exit( 1 );
   }
   free( p );
}

void free_OtherwiseOpt( OtherwiseOpt p )
{
   switch( p->kind )
   {
   case is_OptOtherwiseEmpty:
      break;

   case is_OptOtherwiseSome:
      free( p->u.optOtherwiseSome_.lineeol_ );
      free_StmtList( p->u.optOtherwiseSome_.stmtlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing OtherwiseOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_BreakExprOpt( BreakExprOpt p )
{
   switch( p->kind )
   {
   case is_BreakExprOptEmpty:
      break;

   case is_BreakExprOptSome:
      free_Expr( p->u.breakExprOptSome_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing BreakExprOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_RecoverOpt( RecoverOpt p )
{
   switch( p->kind )
   {
   case is_RecoverOptEmpty:
      break;

   case is_RecoverOptSome:
      free_RecoverUsingOpt( p->u.recoverOptSome_.recoverusingopt_ );
      free( p->u.recoverOptSome_.lineeol_ );
      free_StmtList( p->u.recoverOptSome_.stmtlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing RecoverOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_RecoverUsingOpt( RecoverUsingOpt p )
{
   switch( p->kind )
   {
   case is_RecoverUsingOptEmpty:
      break;

   case is_RecoverUsingOptSome:
      free( p->u.recoverUsingOptSome_.ident_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing RecoverUsingOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndSequence( EndSequence p )
{
   switch( p->kind )
   {
   case is_EndSequenceWord:
      break;

   case is_EndSequenceClause:
      free_EndSequenceOpt( p->u.endSequenceClause_.endsequenceopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndSequence!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndSequenceOpt( EndSequenceOpt p )
{
   switch( p->kind )
   {
   case is_EndSequenceOptEmpty:
      break;

   case is_EndSequenceOptSeq:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndSequenceOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_SwitchCond( SwitchCond p )
{
   switch( p->kind )
   {
   case is_SwitchCondExpr:
      free_Expr( p->u.switchCondExpr_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing SwitchCond!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndSwitch( EndSwitch p )
{
   switch( p->kind )
   {
   case is_EndSwitchWord:
      break;

   case is_EndSwitchClause:
      free_EndSwitchOpt( p->u.endSwitchClause_.endswitchopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndSwitch!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndSwitchOpt( EndSwitchOpt p )
{
   switch( p->kind )
   {
   case is_EndSwitchOptEmpty:
      break;

   case is_EndSwitchOptSwitch:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndSwitchOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndStruct( EndStruct p )
{
   switch( p->kind )
   {
   case is_EndStructWord:
      break;

   case is_EndStructClause:
      free_EndStructOpt( p->u.endStructClause_.endstructopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndStruct!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndStructOpt( EndStructOpt p )
{
   switch( p->kind )
   {
   case is_EndStructOptEmpty:
      break;

   case is_EndStructOptStruct:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndStructOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndClass( EndClass p )
{
   switch( p->kind )
   {
   case is_EndClassWord:
      break;

   case is_EndClassClause:
      free_EndClassOpt( p->u.endClassClause_.endclassopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndClass!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndClassOpt( EndClassOpt p )
{
   switch( p->kind )
   {
   case is_EndClassOptEmpty:
      break;

   case is_EndClassOptClass:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndClassOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndEnum( EndEnum p )
{
   switch( p->kind )
   {
   case is_EndEnumWord:
      break;

   case is_EndEnumClause:
      free_EndEnumOpt( p->u.endEnumClause_.endenumopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndEnum!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EndEnumOpt( EndEnumOpt p )
{
   switch( p->kind )
   {
   case is_EndEnumOptEmpty:
      break;

   case is_EndEnumOptEnum:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EndEnumOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_CaseValue( CaseValue p )
{
   switch( p->kind )
   {
   case is_CaseValueInt:
      free( p->u.caseValueInt_.intlit_ );
      break;

   case is_CaseValueStr:
      free_Napis( p->u.caseValueStr_.napis_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing CaseValue!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StmtEnd( StmtEnd p )
{
   switch( p->kind )
   {
   case is_StmtEndLine:
      free( p->u.stmtEndLine_.lineeol_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StmtEnd!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EnumDecl( EnumDecl p )
{
   switch( p->kind )
   {
   case is_EnumDeclNamed:
      free( p->u.enumDeclNamed_.ident_ );
      free( p->u.enumDeclNamed_.lineeol_ );
      free_EnumListOpt( p->u.enumDeclNamed_.enumlistopt_ );
      free_EndEnum( p->u.enumDeclNamed_.endenum_ );
      free_StmtEnd( p->u.enumDeclNamed_.stmtend_ );
      break;

   case is_EnumDeclAnon:
      free( p->u.enumDeclAnon_.lineeol_ );
      free_EnumListOpt( p->u.enumDeclAnon_.enumlistopt_ );
      free_EndEnum( p->u.enumDeclAnon_.endenum_ );
      free_StmtEnd( p->u.enumDeclAnon_.stmtend_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EnumDecl!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EnumListOpt( EnumListOpt p )
{
   switch( p->kind )
   {
   case is_OptEnumListEmpty:
      break;

   case is_OptEnumListSome:
      free_EnumItem( p->u.optEnumListSome_.enumitem_ );
      free_EnumListTail( p->u.optEnumListSome_.enumlisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EnumListOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EnumListTail( EnumListTail p )
{
   switch( p->kind )
   {
   case is_ListEnumTailEmpty:
      break;

   case is_ListEnumTailCons:
      free_EnumSep( p->u.listEnumTailCons_.enumsep_ );
      free_EnumItem( p->u.listEnumTailCons_.enumitem_ );
      free_EnumListTail( p->u.listEnumTailCons_.enumlisttail_ );
      break;

   case is_ListEnumTailSep:
      free_EnumSep( p->u.listEnumTailSep_.enumsep_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EnumListTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EnumSep( EnumSep p )
{
   switch( p->kind )
   {
   case is_EnumSepComma:
      free_LineEolOpt( p->u.enumSepComma_.lineeolopt_ );
      break;

   case is_EnumSepLine:
      free( p->u.enumSepLine_.lineeol_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EnumSep!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EnumItem( EnumItem p )
{
   switch( p->kind )
   {
   case is_EnumItemDecl:
      free( p->u.enumItemDecl_.ident_ );
      free_EnumValueOpt( p->u.enumItemDecl_.enumvalueopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EnumItem!\n" );
      exit( 1 );
   }
   free( p );
}

void free_EnumValueOpt( EnumValueOpt p )
{
   switch( p->kind )
   {
   case is_OptEnumValueEmpty:
      break;

   case is_OptEnumValueSome:
      free( p->u.optEnumValueSome_.intlit_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing EnumValueOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_LineEolOpt( LineEolOpt p )
{
   switch( p->kind )
   {
   case is_OptLineEolEmpty:
      break;

   case is_OptLineEolSome:
      free( p->u.optLineEolSome_.lineeol_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing LineEolOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StructDecl( StructDecl p )
{
   switch( p->kind )
   {
   case is_StructDeclMain:
      free( p->u.structDeclMain_.ident_ );
      free( p->u.structDeclMain_.lineeol_ );
      free_StructBody( p->u.structDeclMain_.structbody_ );
      free_EndStruct( p->u.structDeclMain_.endstruct_ );
      free_StmtEnd( p->u.structDeclMain_.stmtend_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StructDecl!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StructBody( StructBody p )
{
   switch( p->kind )
   {
   case is_StructBodyEmpty:
      break;

   case is_StructBodyCons:
      free_StructMember( p->u.structBodyCons_.structmember_ );
      free_StructBody( p->u.structBodyCons_.structbody_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StructBody!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StructMember( StructMember p )
{
   switch( p->kind )
   {
   case is_StructMemberVar:
      free_VarList( p->u.structMemberVar_.varlist_ );
      free( p->u.structMemberVar_.lineeol_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StructMember!\n" );
      exit( 1 );
   }
   free( p );
}

void free_FieldInitList( FieldInitList p )
{
   switch( p->kind )
   {
   case is_FieldInitListSingle:
      free_FieldInit( p->u.fieldInitListSingle_.fieldinit_ );
      break;

   case is_FieldInitListCons:
      free_FieldInit( p->u.fieldInitListCons_.fieldinit_ );
      free_FieldInitList( p->u.fieldInitListCons_.fieldinitlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing FieldInitList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_FieldInit( FieldInit p )
{
   switch( p->kind )
   {
   case is_FieldInitItem:
      free( p->u.fieldInitItem_.ident_ );
      free_Expr( p->u.fieldInitItem_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing FieldInit!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticDecl( StaticDecl p )
{
   switch( p->kind )
   {
   case is_StaticStructDecl:
      free( p->u.staticStructDecl_.ident_ );
      free_IdentInitList( p->u.staticStructDecl_.identinitlist_ );
      free_StmtEnd( p->u.staticStructDecl_.stmtend_ );
      break;

   case is_StaticDeclItem:
      free_StaticItemList( p->u.staticDeclItem_.staticitemlist_ );
      free_StmtEnd( p->u.staticDeclItem_.stmtend_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticDecl!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ClassDecl( ClassDecl p )
{
   switch( p->kind )
   {
   case is_ClassDeclMain:
      free_CreateOpt( p->u.classDeclMain_.createopt_ );
      free_ClassName( p->u.classDeclMain_.classname_ );
      free_InheritOpt( p->u.classDeclMain_.inheritopt_ );
      free_StaticClassOpt( p->u.classDeclMain_.staticclassopt_ );
      free( p->u.classDeclMain_.lineeol_ );
      free_ClassBody( p->u.classDeclMain_.classbody_ );
      free_EndClass( p->u.classDeclMain_.endclass_ );
      free_StmtEnd( p->u.classDeclMain_.stmtend_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ClassDecl!\n" );
      exit( 1 );
   }
   free( p );
}

void free_CreateOpt( CreateOpt p )
{
   switch( p->kind )
   {
   case is_OptCreateEmpty:
      break;

   case is_OptCreateSome:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing CreateOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ClassName( ClassName p )
{
   switch( p->kind )
   {
   case is_ClassNameIdent:
      free( p->u.classNameIdent_.ident_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ClassName!\n" );
      exit( 1 );
   }
   free( p );
}

void free_InheritOpt( InheritOpt p )
{
   switch( p->kind )
   {
   case is_OptInheritEmpty:
      break;

   case is_OptInheritSome:
      free_InheritKeyword( p->u.optInheritSome_.inheritkeyword_ );
      free_ClassName( p->u.optInheritSome_.classname_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing InheritOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_InheritKeyword( InheritKeyword p )
{
   switch( p->kind )
   {
   case is_InheritFrom:
      break;

   case is_InheritInherit:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing InheritKeyword!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticClassOpt( StaticClassOpt p )
{
   switch( p->kind )
   {
   case is_OptStaticClassEmpty:
      break;

   case is_OptStaticClassSome:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticClassOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ClassBody( ClassBody p )
{
   switch( p->kind )
   {
   case is_ClassBodyEmpty:
      break;

   case is_ClassBodyCons:
      free_ClassMember( p->u.classBodyCons_.classmember_ );
      free_ClassBody( p->u.classBodyCons_.classbody_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ClassBody!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ClassMember( ClassMember p )
{
   switch( p->kind )
   {
   case is_ClassMemberVisibility:
      free_VisibilityScope( p->u.classMemberVisibility_.visibilityscope_ );
      free( p->u.classMemberVisibility_.lineeol_ );
      break;

   case is_ClassMemberVar:
      free_VarList( p->u.classMemberVar_.varlist_ );
      free( p->u.classMemberVar_.lineeol_ );
      break;

   case is_ClassMemberMethod:
      free( p->u.classMemberMethod_.ident_ );
      free_MethodParamsOpt( p->u.classMemberMethod_.methodparamsopt_ );
      free( p->u.classMemberMethod_.lineeol_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ClassMember!\n" );
      exit( 1 );
   }
   free( p );
}

void free_VisibilityScope( VisibilityScope p )
{
   switch( p->kind )
   {
   case is_VisibilityExported:
      break;

   case is_VisibilityVisible:
      break;

   case is_VisibilityHidden:
      break;

   case is_VisibilityProtected:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing VisibilityScope!\n" );
      exit( 1 );
   }
   free( p );
}

void free_VarList( VarList p )
{
   switch( p->kind )
   {
   case is_VarListSingle:
      free_VarDecl( p->u.varListSingle_.vardecl_ );
      break;

   case is_VarListCons:
      free_VarDecl( p->u.varListCons_.vardecl_ );
      free_VarList( p->u.varListCons_.varlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing VarList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_VarDecl( VarDecl p )
{
   switch( p->kind )
   {
   case is_VarDeclItem:
      free( p->u.varDeclItem_.ident_ );
      free_VarInitOpt( p->u.varDeclItem_.varinitopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing VarDecl!\n" );
      exit( 1 );
   }
   free( p );
}

void free_VarInitOpt( VarInitOpt p )
{
   switch( p->kind )
   {
   case is_OptVarInitEmpty:
      break;

   case is_OptVarInitSome:
      free_Expr( p->u.optVarInitSome_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing VarInitOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_MethodParamsOpt( MethodParamsOpt p )
{
   switch( p->kind )
   {
   case is_MethodParamsEmpty:
      break;

   case is_MethodParamsSome:
      free_ParamListOpt( p->u.methodParamsSome_.paramlistopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing MethodParamsOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_Expr( Expr p )
{
   switch( p->kind )
   {
   case is_ExprAssignBase:
      free_ExprOr( p->u.exprAssignBase_.expror_ );
      break;

   case is_ExprAndDot:
      free_Expr( p->u.exprAndDot_.expr_1 );
      free_Expr( p->u.exprAndDot_.expr_2 );
      break;

   case is_ExprAndBase:
      free_Expr( p->u.exprAndBase_.expr_ );
      break;

   case is_ExprNotDot:
      free_Expr( p->u.exprNotDot_.expr_ );
      break;

   case is_ExprNotBase:
      free_Expr( p->u.exprNotBase_.expr_ );
      break;

   case is_ExprEq:
      free_Expr( p->u.exprEq_.expr_1 );
      free_Expr( p->u.exprEq_.expr_2 );
      break;

   case is_ExprEq2:
      free_Expr( p->u.exprEq2_.expr_1 );
      free_Expr( p->u.exprEq2_.expr_2 );
      break;

   case is_ExprNeq:
      free_Expr( p->u.exprNeq_.expr_1 );
      free_Expr( p->u.exprNeq_.expr_2 );
      break;

   case is_ExprNeq2:
      free_Expr( p->u.exprNeq2_.expr_1 );
      free_Expr( p->u.exprNeq2_.expr_2 );
      break;

   case is_ExprNeq3:
      free_Expr( p->u.exprNeq3_.expr_1 );
      free_Expr( p->u.exprNeq3_.expr_2 );
      break;

   case is_ExprLt:
      free_Expr( p->u.exprLt_.expr_1 );
      free_Expr( p->u.exprLt_.expr_2 );
      break;

   case is_ExprLe:
      free_Expr( p->u.exprLe_.expr_1 );
      free_Expr( p->u.exprLe_.expr_2 );
      break;

   case is_ExprGt:
      free_Expr( p->u.exprGt_.expr_1 );
      free_Expr( p->u.exprGt_.expr_2 );
      break;

   case is_ExprGe:
      free_Expr( p->u.exprGe_.expr_1 );
      free_Expr( p->u.exprGe_.expr_2 );
      break;

   case is_ExprSubStr:
      free_Expr( p->u.exprSubStr_.expr_1 );
      free_Expr( p->u.exprSubStr_.expr_2 );
      break;

   case is_ExprRelBase:
      free_Expr( p->u.exprRelBase_.expr_ );
      break;

   case is_ExprAdd:
      free_Expr( p->u.exprAdd_.expr_1 );
      free_Expr( p->u.exprAdd_.expr_2 );
      break;

   case is_ExprSub:
      free_Expr( p->u.exprSub_.expr_1 );
      free_Expr( p->u.exprSub_.expr_2 );
      break;

   case is_ExprAddBase:
      free_Expr( p->u.exprAddBase_.expr_ );
      break;

   case is_ExprMul:
      free_Expr( p->u.exprMul_.expr_1 );
      free_Expr( p->u.exprMul_.expr_2 );
      break;

   case is_ExprDiv:
      free_Expr( p->u.exprDiv_.expr_1 );
      free_Expr( p->u.exprDiv_.expr_2 );
      break;

   case is_ExprMod:
      free_Expr( p->u.exprMod_.expr_1 );
      free_Expr( p->u.exprMod_.expr_2 );
      break;

   case is_ExprMulBase:
      free_Expr( p->u.exprMulBase_.expr_ );
      break;

   case is_ExprPow1:
      free_Expr( p->u.exprPow1_.expr_1 );
      free_Expr( p->u.exprPow1_.expr_2 );
      break;

   case is_ExprPow2:
      free_Expr( p->u.exprPow2_.expr_1 );
      free_Expr( p->u.exprPow2_.expr_2 );
      break;

   case is_ExprPowBase:
      free_Expr( p->u.exprPowBase_.expr_ );
      break;

   case is_ExprAddrOf:
      free_LHS( p->u.exprAddrOf_.lhs_ );
      break;

   case is_ExprDeref:
      free_Expr( p->u.exprDeref_.expr_ );
      break;

   case is_ExprDecPre:
      free_Expr( p->u.exprDecPre_.expr_ );
      break;

   case is_ExprIncPre:
      free_Expr( p->u.exprIncPre_.expr_ );
      break;

   case is_ExprPlus:
      free_Expr( p->u.exprPlus_.expr_ );
      break;

   case is_ExprMinus:
      free_Expr( p->u.exprMinus_.expr_ );
      break;

   case is_ExprSignBase:
      free_Expr( p->u.exprSignBase_.expr_ );
      break;

   case is_ExprLit:
      free_Literal( p->u.exprLit_.literal_ );
      break;

   case is_ExprCall:
      free_CallExpr( p->u.exprCall_.callexpr_ );
      break;

   case is_ExprQId:
      free_QualifiedId( p->u.exprQId_.qualifiedid_ );
      break;

   case is_ExprParen:
      free_Expr( p->u.exprParen_.expr_ );
      break;

   case is_ExprIndex:
      free_Expr( p->u.exprIndex_.expr_ );
      free_SubscriptList( p->u.exprIndex_.subscriptlist_ );
      break;

   case is_ExprArray:
      free_ExprListOpt( p->u.exprArray_.exprlistopt_ );
      break;

   case is_ExprBlock:
      free_ParamListOpt( p->u.exprBlock_.paramlistopt_ );
      free_ExprListOpt( p->u.exprBlock_.exprlistopt_ );
      break;

   case is_ExprMethodCall:
      free_Expr( p->u.exprMethodCall_.expr_ );
      free( p->u.exprMethodCall_.ident_ );
      free_ArgListOpt( p->u.exprMethodCall_.arglistopt_ );
      break;

   case is_ExprFieldAccess:
      free_Expr( p->u.exprFieldAccess_.expr_ );
      free( p->u.exprFieldAccess_.ident_ );
      break;

   case is_ExprStructInitNamed:
      free_QualifiedId( p->u.exprStructInitNamed_.qualifiedid_ );
      free_FieldInitList( p->u.exprStructInitNamed_.fieldinitlist_ );
      break;

   case is_ExprStructAnon:
      free_FieldInitList( p->u.exprStructAnon_.fieldinitlist_ );
      break;

   case is_ExprDecPost:
      free_Expr( p->u.exprDecPost_.expr_ );
      break;

   case is_ExprIncPost:
      free_Expr( p->u.exprIncPost_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing Expr!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ExprOr( ExprOr p )
{
   switch( p->kind )
   {
   case is_ExprOrDot:
      free_ExprOr( p->u.exprOrDot_.expror_ );
      free_Expr( p->u.exprOrDot_.expr_ );
      break;

   case is_ExprOrBase:
      free_Expr( p->u.exprOrBase_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ExprOr!\n" );
      exit( 1 );
   }
   free( p );
}

void free_CallExpr( CallExpr p )
{
   switch( p->kind )
   {
   case is_CallExprMain:
      free_QualifiedId( p->u.callExprMain_.qualifiedid_ );
      free_ArgListOpt( p->u.callExprMain_.arglistopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing CallExpr!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ArgListOpt( ArgListOpt p )
{
   switch( p->kind )
   {
   case is_OptArgListEmpty:
      break;

   case is_OptArgListSome:
      free_Expr( p->u.optArgListSome_.expr_ );
      free_ArgListTail( p->u.optArgListSome_.arglisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ArgListOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ArgListTail( ArgListTail p )
{
   switch( p->kind )
   {
   case is_ListArgTailEmpty:
      break;

   case is_ListArgTailCons:
      free_Expr( p->u.listArgTailCons_.expr_ );
      free_ArgListTail( p->u.listArgTailCons_.arglisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ArgListTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ExprListOpt( ExprListOpt p )
{
   switch( p->kind )
   {
   case is_OptExprListEmpty:
      break;

   case is_OptExprListSome:
      free_Expr( p->u.optExprListSome_.expr_ );
      free_ExprListTail( p->u.optExprListSome_.exprlisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ExprListOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ExprListTail( ExprListTail p )
{
   switch( p->kind )
   {
   case is_ListExprTailEmpty:
      break;

   case is_ListExprTailCons:
      free_Expr( p->u.listExprTailCons_.expr_ );
      free_ExprListTail( p->u.listExprTailCons_.exprlisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ExprListTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_QualifiedId( QualifiedId p )
{
   switch( p->kind )
   {
   case is_QualifiedIdSingle:
      free( p->u.qualifiedIdSingle_.ident_ );
      break;

   case is_QualifiedIdMore:
      free( p->u.qualifiedIdMore_.ident_ );
      free_QualifiedId( p->u.qualifiedIdMore_.qualifiedid_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing QualifiedId!\n" );
      exit( 1 );
   }
   free( p );
}

void free_LHS( LHS p )
{
   switch( p->kind )
   {
   case is_LHSVal:
      free_LValue( p->u.lHSVal_.lvalue_ );
      break;

   case is_LHSDeref:
      free_Expr( p->u.lHSDeref_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing LHS!\n" );
      exit( 1 );
   }
   free( p );
}

void free_LValue( LValue p )
{
   switch( p->kind )
   {
   case is_LValQId:
      free_QualifiedId( p->u.lValQId_.qualifiedid_ );
      break;

   case is_LValField:
      free_LValue( p->u.lValField_.lvalue_ );
      free( p->u.lValField_.ident_ );
      break;

   case is_LValIndex:
      free_LValue( p->u.lValIndex_.lvalue_ );
      free_SubscriptList( p->u.lValIndex_.subscriptlist_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing LValue!\n" );
      exit( 1 );
   }
   free( p );
}

void free_SubscriptList( SubscriptList p )
{
   switch( p->kind )
   {
   case is_SubscriptListSingle:
      free_Expr( p->u.subscriptListSingle_.expr_ );
      free_SubscriptListTail( p->u.subscriptListSingle_.subscriptlisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing SubscriptList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_SubscriptListTail( SubscriptListTail p )
{
   switch( p->kind )
   {
   case is_ListSubscriptTailEmpty:
      break;

   case is_ListSubscriptTailCons:
      free_Expr( p->u.listSubscriptTailCons_.expr_ );
      free_SubscriptListTail( p->u.listSubscriptTailCons_.subscriptlisttail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing SubscriptListTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_Literal( Literal p )
{
   switch( p->kind )
   {
   case is_LitNil:
      break;

   case is_LitTrueDot:
      break;

   case is_LitFalseDot:
      break;

   case is_LitInt:
      free( p->u.litInt_.intlit_ );
      break;

   case is_LitFloat:
      free( p->u.litFloat_.floatlit_ );
      break;

   case is_LitStr:
      free_Napis( p->u.litStr_.napis_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing Literal!\n" );
      exit( 1 );
   }
   free( p );
}

void free_Napis( Napis p )
{
   switch( p->kind )
   {
   case is_NapisStr:
      free( p->u.napisStr_.strlit_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing Napis!\n" );
      exit( 1 );
   }
   free( p );
}

void free_Def( Def p )
{
   switch( p->kind )
   {
   case is_DefFun:
      free_FunctionDef( p->u.defFun_.functiondef_ );
      break;

   case is_DefProc:
      free_ProcedureDef( p->u.defProc_.proceduredef_ );
      break;

   case is_DefMeth:
      free_MethodDef( p->u.defMeth_.methoddef_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing Def!\n" );
      exit( 1 );
   }
   free( p );
}

void free_FunctionDef( FunctionDef p )
{
   switch( p->kind )
   {
   case is_FunctionDefMain:
      free_StaticOpt( p->u.functionDefMain_.staticopt_ );
      free( p->u.functionDefMain_.ident_ );
      free_ParamListOpt( p->u.functionDefMain_.paramlistopt_ );
      free( p->u.functionDefMain_.lineeol_ );
      free_LocalDeclsOpt( p->u.functionDefMain_.localdeclsopt_ );
      free_StaticDeclsOpt( p->u.functionDefMain_.staticdeclsopt_ );
      free_StmtListNonEmpty( p->u.functionDefMain_.stmtlistnonempty_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing FunctionDef!\n" );
      exit( 1 );
   }
   free( p );
}

void free_ProcedureDef( ProcedureDef p )
{
   switch( p->kind )
   {
   case is_ProcedureDefMain:
      free_StaticOpt( p->u.procedureDefMain_.staticopt_ );
      free( p->u.procedureDefMain_.ident_ );
      free_ParamListOpt( p->u.procedureDefMain_.paramlistopt_ );
      free( p->u.procedureDefMain_.lineeol_ );
      free_LocalDeclsOpt( p->u.procedureDefMain_.localdeclsopt_ );
      free_StaticDeclsOpt( p->u.procedureDefMain_.staticdeclsopt_ );
      free_StmtListNonEmpty( p->u.procedureDefMain_.stmtlistnonempty_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing ProcedureDef!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticOpt( StaticOpt p )
{
   switch( p->kind )
   {
   case is_OptStaticEmpty:
      break;

   case is_OptStaticSome:
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_LocalDeclsOpt( LocalDeclsOpt p )
{
   switch( p->kind )
   {
   case is_ListLocalDeclEmpty:
      break;

   case is_ListLocalDeclLine:
      free( p->u.listLocalDeclLine_.lineeol_ );
      free_LocalDeclsOpt( p->u.listLocalDeclLine_.localdeclsopt_ );
      break;

   case is_ListLocalDeclCons:
      free_LocalDecl( p->u.listLocalDeclCons_.localdecl_ );
      free_LocalDeclsOpt( p->u.listLocalDeclCons_.localdeclsopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing LocalDeclsOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_LocalDecl( LocalDecl p )
{
   switch( p->kind )
   {
   case is_LocalDeclItem:
      free_IdentInitList( p->u.localDeclItem_.identinitlist_ );
      free_StmtEnd( p->u.localDeclItem_.stmtend_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing LocalDecl!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticDeclsOpt( StaticDeclsOpt p )
{
   switch( p->kind )
   {
   case is_ListStaticDeclEmpty:
      break;

   case is_ListStaticDeclCons:
      free_StaticDecl( p->u.listStaticDeclCons_.staticdecl_ );
      free_StaticDeclsOpt( p->u.listStaticDeclCons_.staticdeclsopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticDeclsOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticItemList( StaticItemList p )
{
   switch( p->kind )
   {
   case is_StaticItemListSingle:
      free_StaticItem( p->u.staticItemListSingle_.staticitem_ );
      free_StaticItemTail( p->u.staticItemListSingle_.staticitemtail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticItemList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticItemTail( StaticItemTail p )
{
   switch( p->kind )
   {
   case is_StaticItemTailEmpty:
      break;

   case is_StaticItemTailCons:
      free_StaticItem( p->u.staticItemTailCons_.staticitem_ );
      free_StaticItemTail( p->u.staticItemTailCons_.staticitemtail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticItemTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticItem( StaticItem p )
{
   switch( p->kind )
   {
   case is_StaticItemMain:
      free( p->u.staticItemMain_.ident_ );
      free_StaticArrayDimsOpt( p->u.staticItemMain_.staticarraydimsopt_ );
      free_StaticInitOpt( p->u.staticItemMain_.staticinitopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticItem!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticArrayDimsOpt( StaticArrayDimsOpt p )
{
   switch( p->kind )
   {
   case is_StaticArrayDimsEmpty:
      break;

   case is_StaticArrayDimsCons:
      free_SubscriptList( p->u.staticArrayDimsCons_.subscriptlist_ );
      free_StaticArrayDimsOpt( p->u.staticArrayDimsCons_.staticarraydimsopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticArrayDimsOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_StaticInitOpt( StaticInitOpt p )
{
   switch( p->kind )
   {
   case is_StaticInitEmpty:
      break;

   case is_StaticInitSome:
      free_Expr( p->u.staticInitSome_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing StaticInitOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_IdentInitList( IdentInitList p )
{
   switch( p->kind )
   {
   case is_ListIdentInitSingle:
      free_IdentInit( p->u.listIdentInitSingle_.identinit_ );
      free_IdentInitTail( p->u.listIdentInitSingle_.identinittail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing IdentInitList!\n" );
      exit( 1 );
   }
   free( p );
}

void free_IdentInitTail( IdentInitTail p )
{
   switch( p->kind )
   {
   case is_ListIdentInitTailEmpty:
      break;

   case is_ListIdentInitTailCons:
      free_IdentInit( p->u.listIdentInitTailCons_.identinit_ );
      free_IdentInitTail( p->u.listIdentInitTailCons_.identinittail_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing IdentInitTail!\n" );
      exit( 1 );
   }
   free( p );
}

void free_IdentInit( IdentInit p )
{
   switch( p->kind )
   {
   case is_IdentInitItem:
      free( p->u.identInitItem_.ident_ );
      free_InitOpt( p->u.identInitItem_.initopt_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing IdentInit!\n" );
      exit( 1 );
   }
   free( p );
}

void free_InitOpt( InitOpt p )
{
   switch( p->kind )
   {
   case is_OptInitEmpty:
      break;

   case is_OptInitSome:
      free_Expr( p->u.optInitSome_.expr_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing InitOpt!\n" );
      exit( 1 );
   }
   free( p );
}

void free_MethodDef( MethodDef p )
{
   switch( p->kind )
   {
   case is_MethodDefMain:
      free_StaticOpt( p->u.methodDefMain_.staticopt_ );
      free( p->u.methodDefMain_.ident_ );
      free_ParamListOpt( p->u.methodDefMain_.paramlistopt_ );
      free_ClassName( p->u.methodDefMain_.classname_ );
      free( p->u.methodDefMain_.lineeol_ );
      free_LocalDeclsOpt( p->u.methodDefMain_.localdeclsopt_ );
      free_StaticDeclsOpt( p->u.methodDefMain_.staticdeclsopt_ );
      free_StmtListNonEmpty( p->u.methodDefMain_.stmtlistnonempty_ );
      break;

   default:
      fprintf( stderr, "Error: bad kind field when freeing MethodDef!\n" );
      exit( 1 );
   }
   free( p );
}
